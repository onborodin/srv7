/* soapC.cpp
   Generated by gSOAP 2.8.78 for mob.hh

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.78 2019-03-18 07:44:39 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, tag, NULL, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__StandardPeriodVariant:
		return soap_in_ns1__StandardPeriodVariant(soap, tag, NULL, "ns1:StandardPeriodVariant");
	case SOAP_TYPE_ns1__StandardBeginningDateVariant:
		return soap_in_ns1__StandardBeginningDateVariant(soap, tag, NULL, "ns1:StandardBeginningDateVariant");
	case SOAP_TYPE_ns1__MainClientApplicationWindowMode:
		return soap_in_ns1__MainClientApplicationWindowMode(soap, tag, NULL, "ns1:MainClientApplicationWindowMode");
	case SOAP_TYPE_ns1__FillChecking:
		return soap_in_ns1__FillChecking(soap, tag, NULL, "ns1:FillChecking");
	case SOAP_TYPE_ns1__FillCheckErrorStatus:
		return soap_in_ns1__FillCheckErrorStatus(soap, tag, NULL, "ns1:FillCheckErrorStatus");
	case SOAP_TYPE_ns1__DateFractions:
		return soap_in_ns1__DateFractions(soap, tag, NULL, "ns1:DateFractions");
	case SOAP_TYPE_ns1__AllowedSign:
		return soap_in_ns1__AllowedSign(soap, tag, NULL, "ns1:AllowedSign");
	case SOAP_TYPE_ns1__AllowedLength:
		return soap_in_ns1__AllowedLength(soap, tag, NULL, "ns1:AllowedLength");
	case SOAP_TYPE_ns1__ValueStorage:
		return soap_in_ns1__ValueStorage(soap, tag, NULL, "ns1:ValueStorage");
	case SOAP_TYPE_ns1__UUID:
		return soap_in_ns1__UUID(soap, tag, NULL, "ns1:UUID");
	case SOAP_TYPE_ns1__Type:
		return soap_in_ns1__Type(soap, tag, NULL, "xsd:QName");
	case SOAP_TYPE_ns1__ObjectVersion:
		return soap_in_ns1__ObjectVersion(soap, tag, NULL, "ns1:ObjectVersion");
	case SOAP_TYPE_ns1__Null:
		return soap_in_ns1__Null(soap, tag, NULL, "ns1:Null");
	case SOAP_TYPE_ns1__CompositeID:
		return soap_in_ns1__CompositeID(soap, tag, NULL, "ns1:CompositeID");
	case SOAP_TYPE_ns1__ValueTreeRow:
		return soap_in_ns1__ValueTreeRow(soap, tag, NULL, "ns1:ValueTreeRow");
	case SOAP_TYPE_ns1__ValueTreeColumn:
		return soap_in_ns1__ValueTreeColumn(soap, tag, NULL, "ns1:ValueTreeColumn");
	case SOAP_TYPE_ns1__ValueTree:
		return soap_in_ns1__ValueTree(soap, tag, NULL, "ns1:ValueTree");
	case SOAP_TYPE_ns1__ValueTableRow:
		return soap_in_ns1__ValueTableRow(soap, tag, NULL, "ns1:ValueTableRow");
	case SOAP_TYPE_ns1__ValueTableIndex:
		return soap_in_ns1__ValueTableIndex(soap, tag, NULL, "ns1:ValueTableIndex");
	case SOAP_TYPE_ns1__ValueTableColumn:
		return soap_in_ns1__ValueTableColumn(soap, tag, NULL, "ns1:ValueTableColumn");
	case SOAP_TYPE_ns1__ValueTable:
		return soap_in_ns1__ValueTable(soap, tag, NULL, "ns1:ValueTable");
	case SOAP_TYPE_ns1__ValueListType:
		return soap_in_ns1__ValueListType(soap, tag, NULL, "ns1:ValueListType");
	case SOAP_TYPE_ns1__ValueListItemType:
		return soap_in_ns1__ValueListItemType(soap, tag, NULL, "ns1:ValueListItemType");
	case SOAP_TYPE_ns1__TypeDescription:
		return soap_in_ns1__TypeDescription(soap, tag, NULL, "ns1:TypeDescription");
	case SOAP_TYPE_ns1__Structure:
		return soap_in_ns1__Structure(soap, tag, NULL, "ns1:Structure");
	case SOAP_TYPE_ns1__StringQualifiers:
		return soap_in_ns1__StringQualifiers(soap, tag, NULL, "ns1:StringQualifiers");
	case SOAP_TYPE_ns1__StandardPeriod:
		return soap_in_ns1__StandardPeriod(soap, tag, NULL, "ns1:StandardPeriod");
	case SOAP_TYPE_ns1__StandardBeginningDate:
		return soap_in_ns1__StandardBeginningDate(soap, tag, NULL, "ns1:StandardBeginningDate");
	case SOAP_TYPE_ns1__NumberQualifiers:
		return soap_in_ns1__NumberQualifiers(soap, tag, NULL, "ns1:NumberQualifiers");
	case SOAP_TYPE_ns1__Map:
		return soap_in_ns1__Map(soap, tag, NULL, "ns1:Map");
	case SOAP_TYPE_ns1__LocalStringType:
		return soap_in_ns1__LocalStringType(soap, tag, NULL, "ns1:LocalStringType");
	case SOAP_TYPE_ns1__LocalStringItemType:
		return soap_in_ns1__LocalStringItemType(soap, tag, NULL, "ns1:LocalStringItemType");
	case SOAP_TYPE_ns1__KeyAndValue:
		return soap_in_ns1__KeyAndValue(soap, tag, NULL, "ns1:KeyAndValue");
	case SOAP_TYPE_ns1__GenericException:
		return soap_in_ns1__GenericException(soap, tag, NULL, "ns1:GenericException");
	case SOAP_TYPE_ns1__FixedStructure:
		return soap_in_ns1__FixedStructure(soap, tag, NULL, "ns1:FixedStructure");
	case SOAP_TYPE_ns1__FixedMap:
		return soap_in_ns1__FixedMap(soap, tag, NULL, "ns1:FixedMap");
	case SOAP_TYPE_ns1__FixedArray:
		return soap_in_ns1__FixedArray(soap, tag, NULL, "ns1:FixedArray");
	case SOAP_TYPE_ns1__Exception:
		return soap_in_ns1__Exception(soap, tag, NULL, "ns1:Exception");
	case SOAP_TYPE_ns1__DateQualifiers:
		return soap_in_ns1__DateQualifiers(soap, tag, NULL, "ns1:DateQualifiers");
	case SOAP_TYPE_ns1__DataFillErrors:
		return soap_in_ns1__DataFillErrors(soap, tag, NULL, "ns1:DataFillErrors");
	case SOAP_TYPE_ns1__DataFillError:
		return soap_in_ns1__DataFillError(soap, tag, NULL, "ns1:DataFillError");
	case SOAP_TYPE_ns1__BinaryDataQualifiers:
		return soap_in_ns1__BinaryDataQualifiers(soap, tag, NULL, "ns1:BinaryDataQualifiers");
	case SOAP_TYPE_ns1__Array:
		return soap_in_ns1__Array(soap, tag, NULL, "ns1:Array");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, tag, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, tag, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__NMTOKEN:
		return soap_in_xsd__NMTOKEN(soap, tag, NULL, "xsd:NMTOKEN");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, tag, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, tag, NULL, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__MozaicAuthorization:
		return soap_in_PointerTo_ns1__MozaicAuthorization(soap, tag, NULL, "ns1:MozaicAuthorization");
	case SOAP_TYPE_PointerTo_ns1__СинхронизацияСправочнойИнформации:
		return soap_in_PointerTo_ns1__СинхронизацияСправочнойИнформации(soap, tag, NULL, "ns1:СинхронизацияСправочнойИнформации");
	case SOAP_TYPE_PointerTo_ns1__ВыгрузкаСправочнойИнформации:
		return soap_in_PointerTo_ns1__ВыгрузкаСправочнойИнформации(soap, tag, NULL, "ns1:ВыгрузкаСправочнойИнформации");
	case SOAP_TYPE_PointerTo_ns1__ПринятьПакетОбмена:
		return soap_in_PointerTo_ns1__ПринятьПакетОбмена(soap, tag, NULL, "ns1:ПринятьПакетОбмена");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, tag, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__ValueStorage:
		return soap_in_PointerTons1__ValueStorage(soap, tag, NULL, "ns1:ValueStorage");
	case SOAP_TYPE_PointerTons1__ValueTreeRow:
		return soap_in_PointerTons1__ValueTreeRow(soap, tag, NULL, "ns1:ValueTreeRow");
	case SOAP_TYPE_PointerTons1__ValueTreeColumn:
		return soap_in_PointerTons1__ValueTreeColumn(soap, tag, NULL, "ns1:ValueTreeColumn");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_in_PointerToxsd__nonNegativeInteger(soap, tag, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerToxsd__NMTOKEN:
		return soap_in_PointerToxsd__NMTOKEN(soap, tag, NULL, "xsd:NMTOKEN");
	case SOAP_TYPE_PointerTons1__ValueTableRow:
		return soap_in_PointerTons1__ValueTableRow(soap, tag, NULL, "ns1:ValueTableRow");
	case SOAP_TYPE_PointerTons1__ValueTableIndex:
		return soap_in_PointerTons1__ValueTableIndex(soap, tag, NULL, "ns1:ValueTableIndex");
	case SOAP_TYPE_PointerTons1__ValueTableColumn:
		return soap_in_PointerTons1__ValueTableColumn(soap, tag, NULL, "ns1:ValueTableColumn");
	case SOAP_TYPE_PointerTons1__ValueListItemType:
		return soap_in_PointerTons1__ValueListItemType(soap, tag, NULL, "ns1:ValueListItemType");
	case SOAP_TYPE_PointerTons1__ValueListType:
		return soap_in_PointerTons1__ValueListType(soap, tag, NULL, "ns1:ValueListType");
	case SOAP_TYPE_PointerTons1__TypeDescription:
		return soap_in_PointerTons1__TypeDescription(soap, tag, NULL, "ns1:TypeDescription");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, tag, NULL, "xsd:long");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_in_PointerToxsd__decimal(soap, tag, NULL, "xsd:decimal");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__BinaryDataQualifiers:
		return soap_in_PointerTons1__BinaryDataQualifiers(soap, tag, NULL, "ns1:BinaryDataQualifiers");
	case SOAP_TYPE_PointerTons1__DateQualifiers:
		return soap_in_PointerTons1__DateQualifiers(soap, tag, NULL, "ns1:DateQualifiers");
	case SOAP_TYPE_PointerTons1__StringQualifiers:
		return soap_in_PointerTons1__StringQualifiers(soap, tag, NULL, "ns1:StringQualifiers");
	case SOAP_TYPE_PointerTons1__NumberQualifiers:
		return soap_in_PointerTons1__NumberQualifiers(soap, tag, NULL, "ns1:NumberQualifiers");
	case SOAP_TYPE_PointerTodateTime:
		return soap_in_PointerTodateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__LocalStringItemType:
		return soap_in_PointerTons1__LocalStringItemType(soap, tag, NULL, "ns1:LocalStringItemType");
	case SOAP_TYPE_PointerTons1__GenericException:
		return soap_in_PointerTons1__GenericException(soap, tag, NULL, "ns1:GenericException");
	case SOAP_TYPE_PointerTons1__KeyAndValue:
		return soap_in_PointerTons1__KeyAndValue(soap, tag, NULL, "ns1:KeyAndValue");
	case SOAP_TYPE_PointerTons1__DataFillError:
		return soap_in_PointerTons1__DataFillError(soap, tag, NULL, "ns1:DataFillError");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:ValueStorage"))
		{	*type = SOAP_TYPE_ns1__ValueStorage;
			return soap_in_ns1__ValueStorage(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UUID"))
		{	*type = SOAP_TYPE_ns1__UUID;
			return soap_in_ns1__UUID(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_ns1__Type;
			return soap_in_ns1__Type(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ObjectVersion"))
		{	*type = SOAP_TYPE_ns1__ObjectVersion;
			return soap_in_ns1__ObjectVersion(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Null"))
		{	*type = SOAP_TYPE_ns1__Null;
			return soap_in_ns1__Null(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CompositeID"))
		{	*type = SOAP_TYPE_ns1__CompositeID;
			return soap_in_ns1__CompositeID(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ValueTreeRow"))
		{	*type = SOAP_TYPE_ns1__ValueTreeRow;
			return soap_in_ns1__ValueTreeRow(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ValueTreeColumn"))
		{	*type = SOAP_TYPE_ns1__ValueTreeColumn;
			return soap_in_ns1__ValueTreeColumn(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ValueTree"))
		{	*type = SOAP_TYPE_ns1__ValueTree;
			return soap_in_ns1__ValueTree(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ValueTableRow"))
		{	*type = SOAP_TYPE_ns1__ValueTableRow;
			return soap_in_ns1__ValueTableRow(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ValueTableIndex"))
		{	*type = SOAP_TYPE_ns1__ValueTableIndex;
			return soap_in_ns1__ValueTableIndex(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ValueTableColumn"))
		{	*type = SOAP_TYPE_ns1__ValueTableColumn;
			return soap_in_ns1__ValueTableColumn(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ValueTable"))
		{	*type = SOAP_TYPE_ns1__ValueTable;
			return soap_in_ns1__ValueTable(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ValueListType"))
		{	*type = SOAP_TYPE_ns1__ValueListType;
			return soap_in_ns1__ValueListType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ValueListItemType"))
		{	*type = SOAP_TYPE_ns1__ValueListItemType;
			return soap_in_ns1__ValueListItemType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TypeDescription"))
		{	*type = SOAP_TYPE_ns1__TypeDescription;
			return soap_in_ns1__TypeDescription(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Structure"))
		{	*type = SOAP_TYPE_ns1__Structure;
			return soap_in_ns1__Structure(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StringQualifiers"))
		{	*type = SOAP_TYPE_ns1__StringQualifiers;
			return soap_in_ns1__StringQualifiers(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StandardPeriod"))
		{	*type = SOAP_TYPE_ns1__StandardPeriod;
			return soap_in_ns1__StandardPeriod(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StandardBeginningDate"))
		{	*type = SOAP_TYPE_ns1__StandardBeginningDate;
			return soap_in_ns1__StandardBeginningDate(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NumberQualifiers"))
		{	*type = SOAP_TYPE_ns1__NumberQualifiers;
			return soap_in_ns1__NumberQualifiers(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Map"))
		{	*type = SOAP_TYPE_ns1__Map;
			return soap_in_ns1__Map(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LocalStringType"))
		{	*type = SOAP_TYPE_ns1__LocalStringType;
			return soap_in_ns1__LocalStringType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LocalStringItemType"))
		{	*type = SOAP_TYPE_ns1__LocalStringItemType;
			return soap_in_ns1__LocalStringItemType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:KeyAndValue"))
		{	*type = SOAP_TYPE_ns1__KeyAndValue;
			return soap_in_ns1__KeyAndValue(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenericException"))
		{	*type = SOAP_TYPE_ns1__GenericException;
			return soap_in_ns1__GenericException(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FixedStructure"))
		{	*type = SOAP_TYPE_ns1__FixedStructure;
			return soap_in_ns1__FixedStructure(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FixedMap"))
		{	*type = SOAP_TYPE_ns1__FixedMap;
			return soap_in_ns1__FixedMap(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FixedArray"))
		{	*type = SOAP_TYPE_ns1__FixedArray;
			return soap_in_ns1__FixedArray(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Exception"))
		{	*type = SOAP_TYPE_ns1__Exception;
			return soap_in_ns1__Exception(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DateQualifiers"))
		{	*type = SOAP_TYPE_ns1__DateQualifiers;
			return soap_in_ns1__DateQualifiers(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataFillErrors"))
		{	*type = SOAP_TYPE_ns1__DataFillErrors;
			return soap_in_ns1__DataFillErrors(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataFillError"))
		{	*type = SOAP_TYPE_ns1__DataFillError;
			return soap_in_ns1__DataFillError(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BinaryDataQualifiers"))
		{	*type = SOAP_TYPE_ns1__BinaryDataQualifiers;
			return soap_in_ns1__BinaryDataQualifiers(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Array"))
		{	*type = SOAP_TYPE_ns1__Array;
			return soap_in_ns1__Array(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NMTOKEN"))
		{	*type = SOAP_TYPE_xsd__NMTOKEN;
			return soap_in_xsd__NMTOKEN(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StandardPeriodVariant"))
		{	*type = SOAP_TYPE_ns1__StandardPeriodVariant;
			return soap_in_ns1__StandardPeriodVariant(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StandardBeginningDateVariant"))
		{	*type = SOAP_TYPE_ns1__StandardBeginningDateVariant;
			return soap_in_ns1__StandardBeginningDateVariant(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MainClientApplicationWindowMode"))
		{	*type = SOAP_TYPE_ns1__MainClientApplicationWindowMode;
			return soap_in_ns1__MainClientApplicationWindowMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FillChecking"))
		{	*type = SOAP_TYPE_ns1__FillChecking;
			return soap_in_ns1__FillChecking(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FillCheckErrorStatus"))
		{	*type = SOAP_TYPE_ns1__FillCheckErrorStatus;
			return soap_in_ns1__FillCheckErrorStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DateFractions"))
		{	*type = SOAP_TYPE_ns1__DateFractions;
			return soap_in_ns1__DateFractions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AllowedSign"))
		{	*type = SOAP_TYPE_ns1__AllowedSign;
			return soap_in_ns1__AllowedSign(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AllowedLength"))
		{	*type = SOAP_TYPE_ns1__AllowedLength;
			return soap_in_ns1__AllowedLength(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:Structure-Property"))
		{	*type = SOAP_TYPE__ns1__Structure_Property;
			return soap_in__ns1__Structure_Property(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FixedStructure-Property"))
		{	*type = SOAP_TYPE__ns1__FixedStructure_Property;
			return soap_in__ns1__FixedStructure_Property(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MozaicAuthorizationResponse"))
		{	*type = SOAP_TYPE__ns1__MozaicAuthorizationResponse;
			return soap_in__ns1__MozaicAuthorizationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MozaicAuthorization"))
		{	*type = SOAP_TYPE__ns1__MozaicAuthorization;
			return soap_in__ns1__MozaicAuthorization(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:СинхронизацияСправочнойИнформацииResponse"))
		{	*type = SOAP_TYPE__ns1__СинхронизацияСправочнойИнформацииResponse;
			return soap_in__ns1__СинхронизацияСправочнойИнформацииResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:СинхронизацияСправочнойИнформации"))
		{	*type = SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации;
			return soap_in__ns1__СинхронизацияСправочнойИнформации(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ВыгрузкаСправочнойИнформацииResponse"))
		{	*type = SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформацииResponse;
			return soap_in__ns1__ВыгрузкаСправочнойИнформацииResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ВыгрузкаСправочнойИнформации"))
		{	*type = SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации;
			return soap_in__ns1__ВыгрузкаСправочнойИнформации(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ПринятьПакетОбменаResponse"))
		{	*type = SOAP_TYPE__ns1__ПринятьПакетОбменаResponse;
			return soap_in__ns1__ПринятьПакетОбменаResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ПринятьПакетОбмена"))
		{	*type = SOAP_TYPE__ns1__ПринятьПакетОбмена;
			return soap_in__ns1__ПринятьПакетОбмена(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__StandardPeriodVariant:
		return soap_out_ns1__StandardPeriodVariant(soap, tag, id, (const enum ns1__StandardPeriodVariant *)ptr, "ns1:StandardPeriodVariant");
	case SOAP_TYPE_ns1__StandardBeginningDateVariant:
		return soap_out_ns1__StandardBeginningDateVariant(soap, tag, id, (const enum ns1__StandardBeginningDateVariant *)ptr, "ns1:StandardBeginningDateVariant");
	case SOAP_TYPE_ns1__MainClientApplicationWindowMode:
		return soap_out_ns1__MainClientApplicationWindowMode(soap, tag, id, (const enum ns1__MainClientApplicationWindowMode *)ptr, "ns1:MainClientApplicationWindowMode");
	case SOAP_TYPE_ns1__FillChecking:
		return soap_out_ns1__FillChecking(soap, tag, id, (const enum ns1__FillChecking *)ptr, "ns1:FillChecking");
	case SOAP_TYPE_ns1__FillCheckErrorStatus:
		return soap_out_ns1__FillCheckErrorStatus(soap, tag, id, (const enum ns1__FillCheckErrorStatus *)ptr, "ns1:FillCheckErrorStatus");
	case SOAP_TYPE_ns1__DateFractions:
		return soap_out_ns1__DateFractions(soap, tag, id, (const enum ns1__DateFractions *)ptr, "ns1:DateFractions");
	case SOAP_TYPE_ns1__AllowedSign:
		return soap_out_ns1__AllowedSign(soap, tag, id, (const enum ns1__AllowedSign *)ptr, "ns1:AllowedSign");
	case SOAP_TYPE_ns1__AllowedLength:
		return soap_out_ns1__AllowedLength(soap, tag, id, (const enum ns1__AllowedLength *)ptr, "ns1:AllowedLength");
	case SOAP_TYPE__ns1__Structure_Property:
		return ((_ns1__Structure_Property *)ptr)->soap_out(soap, "ns1:Structure-Property", id, "");
	case SOAP_TYPE__ns1__FixedStructure_Property:
		return ((_ns1__FixedStructure_Property *)ptr)->soap_out(soap, "ns1:FixedStructure-Property", id, "");
	case SOAP_TYPE_ns1__ValueStorage:
		return soap_out_ns1__ValueStorage(soap, tag, id, (const xsd__base64Binary *)ptr, "ns1:ValueStorage");
	case SOAP_TYPE_ns1__UUID:
		return soap_out_ns1__UUID(soap, tag, id, (const std::string *)ptr, "ns1:UUID");
	case SOAP_TYPE_ns1__Type:
		return soap_out_ns1__Type(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_ns1__ObjectVersion:
		return soap_out_ns1__ObjectVersion(soap, tag, id, (const std::string *)ptr, "ns1:ObjectVersion");
	case SOAP_TYPE_ns1__Null:
		return soap_out_ns1__Null(soap, tag, id, (const std::string *)ptr, "ns1:Null");
	case SOAP_TYPE_ns1__CompositeID:
		return soap_out_ns1__CompositeID(soap, tag, id, (const std::string *)ptr, "ns1:CompositeID");
	case SOAP_TYPE__ns1__MozaicAuthorizationResponse:
		return ((_ns1__MozaicAuthorizationResponse *)ptr)->soap_out(soap, "ns1:MozaicAuthorizationResponse", id, "");
	case SOAP_TYPE__ns1__MozaicAuthorization:
		return ((_ns1__MozaicAuthorization *)ptr)->soap_out(soap, "ns1:MozaicAuthorization", id, "");
	case SOAP_TYPE__ns1__СинхронизацияСправочнойИнформацииResponse:
		return ((_ns1__СинхронизацияСправочнойИнформацииResponse *)ptr)->soap_out(soap, "ns1:СинхронизацияСправочнойИнформацииResponse", id, "");
	case SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации:
		return ((_ns1__СинхронизацияСправочнойИнформации *)ptr)->soap_out(soap, "ns1:СинхронизацияСправочнойИнформации", id, "");
	case SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформацииResponse:
		return ((_ns1__ВыгрузкаСправочнойИнформацииResponse *)ptr)->soap_out(soap, "ns1:ВыгрузкаСправочнойИнформацииResponse", id, "");
	case SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации:
		return ((_ns1__ВыгрузкаСправочнойИнформации *)ptr)->soap_out(soap, "ns1:ВыгрузкаСправочнойИнформации", id, "");
	case SOAP_TYPE__ns1__ПринятьПакетОбменаResponse:
		return ((_ns1__ПринятьПакетОбменаResponse *)ptr)->soap_out(soap, "ns1:ПринятьПакетОбменаResponse", id, "");
	case SOAP_TYPE__ns1__ПринятьПакетОбмена:
		return ((_ns1__ПринятьПакетОбмена *)ptr)->soap_out(soap, "ns1:ПринятьПакетОбмена", id, "");
	case SOAP_TYPE_ns1__ValueTreeRow:
		return ((ns1__ValueTreeRow *)ptr)->soap_out(soap, tag, id, "ns1:ValueTreeRow");
	case SOAP_TYPE_ns1__ValueTreeColumn:
		return ((ns1__ValueTreeColumn *)ptr)->soap_out(soap, tag, id, "ns1:ValueTreeColumn");
	case SOAP_TYPE_ns1__ValueTree:
		return ((ns1__ValueTree *)ptr)->soap_out(soap, tag, id, "ns1:ValueTree");
	case SOAP_TYPE_ns1__ValueTableRow:
		return ((ns1__ValueTableRow *)ptr)->soap_out(soap, tag, id, "ns1:ValueTableRow");
	case SOAP_TYPE_ns1__ValueTableIndex:
		return ((ns1__ValueTableIndex *)ptr)->soap_out(soap, tag, id, "ns1:ValueTableIndex");
	case SOAP_TYPE_ns1__ValueTableColumn:
		return ((ns1__ValueTableColumn *)ptr)->soap_out(soap, tag, id, "ns1:ValueTableColumn");
	case SOAP_TYPE_ns1__ValueTable:
		return ((ns1__ValueTable *)ptr)->soap_out(soap, tag, id, "ns1:ValueTable");
	case SOAP_TYPE_ns1__ValueListType:
		return ((ns1__ValueListType *)ptr)->soap_out(soap, tag, id, "ns1:ValueListType");
	case SOAP_TYPE_ns1__ValueListItemType:
		return ((ns1__ValueListItemType *)ptr)->soap_out(soap, tag, id, "ns1:ValueListItemType");
	case SOAP_TYPE_ns1__TypeDescription:
		return ((ns1__TypeDescription *)ptr)->soap_out(soap, tag, id, "ns1:TypeDescription");
	case SOAP_TYPE_ns1__Structure:
		return ((ns1__Structure *)ptr)->soap_out(soap, tag, id, "ns1:Structure");
	case SOAP_TYPE_ns1__StringQualifiers:
		return ((ns1__StringQualifiers *)ptr)->soap_out(soap, tag, id, "ns1:StringQualifiers");
	case SOAP_TYPE_ns1__StandardPeriod:
		return ((ns1__StandardPeriod *)ptr)->soap_out(soap, tag, id, "ns1:StandardPeriod");
	case SOAP_TYPE_ns1__StandardBeginningDate:
		return ((ns1__StandardBeginningDate *)ptr)->soap_out(soap, tag, id, "ns1:StandardBeginningDate");
	case SOAP_TYPE_ns1__NumberQualifiers:
		return ((ns1__NumberQualifiers *)ptr)->soap_out(soap, tag, id, "ns1:NumberQualifiers");
	case SOAP_TYPE_ns1__Map:
		return ((ns1__Map *)ptr)->soap_out(soap, tag, id, "ns1:Map");
	case SOAP_TYPE_ns1__LocalStringType:
		return ((ns1__LocalStringType *)ptr)->soap_out(soap, tag, id, "ns1:LocalStringType");
	case SOAP_TYPE_ns1__LocalStringItemType:
		return ((ns1__LocalStringItemType *)ptr)->soap_out(soap, tag, id, "ns1:LocalStringItemType");
	case SOAP_TYPE_ns1__KeyAndValue:
		return ((ns1__KeyAndValue *)ptr)->soap_out(soap, tag, id, "ns1:KeyAndValue");
	case SOAP_TYPE_ns1__GenericException:
		return ((ns1__GenericException *)ptr)->soap_out(soap, tag, id, "ns1:GenericException");
	case SOAP_TYPE_ns1__FixedStructure:
		return ((ns1__FixedStructure *)ptr)->soap_out(soap, tag, id, "ns1:FixedStructure");
	case SOAP_TYPE_ns1__FixedMap:
		return ((ns1__FixedMap *)ptr)->soap_out(soap, tag, id, "ns1:FixedMap");
	case SOAP_TYPE_ns1__FixedArray:
		return ((ns1__FixedArray *)ptr)->soap_out(soap, tag, id, "ns1:FixedArray");
	case SOAP_TYPE_ns1__Exception:
		return ((ns1__Exception *)ptr)->soap_out(soap, tag, id, "ns1:Exception");
	case SOAP_TYPE_ns1__DateQualifiers:
		return ((ns1__DateQualifiers *)ptr)->soap_out(soap, tag, id, "ns1:DateQualifiers");
	case SOAP_TYPE_ns1__DataFillErrors:
		return ((ns1__DataFillErrors *)ptr)->soap_out(soap, tag, id, "ns1:DataFillErrors");
	case SOAP_TYPE_ns1__DataFillError:
		return ((ns1__DataFillError *)ptr)->soap_out(soap, tag, id, "ns1:DataFillError");
	case SOAP_TYPE_ns1__BinaryDataQualifiers:
		return ((ns1__BinaryDataQualifiers *)ptr)->soap_out(soap, tag, id, "ns1:BinaryDataQualifiers");
	case SOAP_TYPE_ns1__Array:
		return ((ns1__Array *)ptr)->soap_out(soap, tag, id, "ns1:Array");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::string *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__NMTOKEN:
		return soap_out_xsd__NMTOKEN(soap, tag, id, (const std::string *)ptr, "xsd:NMTOKEN");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__MozaicAuthorization:
		return soap_out_PointerTo_ns1__MozaicAuthorization(soap, tag, id, (_ns1__MozaicAuthorization *const*)ptr, "ns1:MozaicAuthorization");
	case SOAP_TYPE_PointerTo_ns1__СинхронизацияСправочнойИнформации:
		return soap_out_PointerTo_ns1__СинхронизацияСправочнойИнформации(soap, tag, id, (_ns1__СинхронизацияСправочнойИнформации *const*)ptr, "ns1:СинхронизацияСправочнойИнформации");
	case SOAP_TYPE_PointerTo_ns1__ВыгрузкаСправочнойИнформации:
		return soap_out_PointerTo_ns1__ВыгрузкаСправочнойИнформации(soap, tag, id, (_ns1__ВыгрузкаСправочнойИнформации *const*)ptr, "ns1:ВыгрузкаСправочнойИнформации");
	case SOAP_TYPE_PointerTo_ns1__ПринятьПакетОбмена:
		return soap_out_PointerTo_ns1__ПринятьПакетОбмена(soap, tag, id, (_ns1__ПринятьПакетОбмена *const*)ptr, "ns1:ПринятьПакетОбмена");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__ValueStorage:
		return soap_out_PointerTons1__ValueStorage(soap, tag, id, (xsd__base64Binary *const*)ptr, "ns1:ValueStorage");
	case SOAP_TYPE_PointerTons1__ValueTreeRow:
		return soap_out_PointerTons1__ValueTreeRow(soap, tag, id, (ns1__ValueTreeRow *const*)ptr, "ns1:ValueTreeRow");
	case SOAP_TYPE_PointerTons1__ValueTreeColumn:
		return soap_out_PointerTons1__ValueTreeColumn(soap, tag, id, (ns1__ValueTreeColumn *const*)ptr, "ns1:ValueTreeColumn");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_out_PointerToxsd__nonNegativeInteger(soap, tag, id, (std::string *const*)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerToxsd__NMTOKEN:
		return soap_out_PointerToxsd__NMTOKEN(soap, tag, id, (std::string *const*)ptr, "xsd:NMTOKEN");
	case SOAP_TYPE_PointerTons1__ValueTableRow:
		return soap_out_PointerTons1__ValueTableRow(soap, tag, id, (ns1__ValueTableRow *const*)ptr, "ns1:ValueTableRow");
	case SOAP_TYPE_PointerTons1__ValueTableIndex:
		return soap_out_PointerTons1__ValueTableIndex(soap, tag, id, (ns1__ValueTableIndex *const*)ptr, "ns1:ValueTableIndex");
	case SOAP_TYPE_PointerTons1__ValueTableColumn:
		return soap_out_PointerTons1__ValueTableColumn(soap, tag, id, (ns1__ValueTableColumn *const*)ptr, "ns1:ValueTableColumn");
	case SOAP_TYPE_PointerTons1__ValueListItemType:
		return soap_out_PointerTons1__ValueListItemType(soap, tag, id, (ns1__ValueListItemType *const*)ptr, "ns1:ValueListItemType");
	case SOAP_TYPE_PointerTons1__ValueListType:
		return soap_out_PointerTons1__ValueListType(soap, tag, id, (ns1__ValueListType *const*)ptr, "ns1:ValueListType");
	case SOAP_TYPE_PointerTons1__TypeDescription:
		return soap_out_PointerTons1__TypeDescription(soap, tag, id, (ns1__TypeDescription *const*)ptr, "ns1:TypeDescription");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_out_PointerToxsd__decimal(soap, tag, id, (std::string *const*)ptr, "xsd:decimal");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__BinaryDataQualifiers:
		return soap_out_PointerTons1__BinaryDataQualifiers(soap, tag, id, (ns1__BinaryDataQualifiers *const*)ptr, "ns1:BinaryDataQualifiers");
	case SOAP_TYPE_PointerTons1__DateQualifiers:
		return soap_out_PointerTons1__DateQualifiers(soap, tag, id, (ns1__DateQualifiers *const*)ptr, "ns1:DateQualifiers");
	case SOAP_TYPE_PointerTons1__StringQualifiers:
		return soap_out_PointerTons1__StringQualifiers(soap, tag, id, (ns1__StringQualifiers *const*)ptr, "ns1:StringQualifiers");
	case SOAP_TYPE_PointerTons1__NumberQualifiers:
		return soap_out_PointerTons1__NumberQualifiers(soap, tag, id, (ns1__NumberQualifiers *const*)ptr, "ns1:NumberQualifiers");
	case SOAP_TYPE_PointerTodateTime:
		return soap_out_PointerTodateTime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__LocalStringItemType:
		return soap_out_PointerTons1__LocalStringItemType(soap, tag, id, (ns1__LocalStringItemType *const*)ptr, "ns1:LocalStringItemType");
	case SOAP_TYPE_PointerTons1__GenericException:
		return soap_out_PointerTons1__GenericException(soap, tag, id, (ns1__GenericException *const*)ptr, "ns1:GenericException");
	case SOAP_TYPE_PointerTons1__KeyAndValue:
		return soap_out_PointerTons1__KeyAndValue(soap, tag, id, (ns1__KeyAndValue *const*)ptr, "ns1:KeyAndValue");
	case SOAP_TYPE_PointerTons1__DataFillError:
		return soap_out_PointerTons1__DataFillError(soap, tag, id, (ns1__DataFillError *const*)ptr, "ns1:DataFillError");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__Structure_Property:
		((_ns1__Structure_Property *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__FixedStructure_Property:
		((_ns1__FixedStructure_Property *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ValueStorage:
		soap_serialize_ns1__ValueStorage(soap, (const xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE_ns1__UUID:
		soap_serialize_ns1__UUID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Type:
		soap_serialize_ns1__Type(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__ObjectVersion:
		soap_serialize_ns1__ObjectVersion(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__Null:
		soap_serialize_ns1__Null(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__CompositeID:
		soap_serialize_ns1__CompositeID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns1__MozaicAuthorizationResponse:
		((_ns1__MozaicAuthorizationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__MozaicAuthorization:
		((_ns1__MozaicAuthorization *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__СинхронизацияСправочнойИнформацииResponse:
		((_ns1__СинхронизацияСправочнойИнформацииResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации:
		((_ns1__СинхронизацияСправочнойИнформации *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформацииResponse:
		((_ns1__ВыгрузкаСправочнойИнформацииResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации:
		((_ns1__ВыгрузкаСправочнойИнформации *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ПринятьПакетОбменаResponse:
		((_ns1__ПринятьПакетОбменаResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ПринятьПакетОбмена:
		((_ns1__ПринятьПакетОбмена *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ValueTreeRow:
		((ns1__ValueTreeRow *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ValueTreeColumn:
		((ns1__ValueTreeColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ValueTree:
		((ns1__ValueTree *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ValueTableRow:
		((ns1__ValueTableRow *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ValueTableIndex:
		((ns1__ValueTableIndex *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ValueTableColumn:
		((ns1__ValueTableColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ValueTable:
		((ns1__ValueTable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ValueListType:
		((ns1__ValueListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ValueListItemType:
		((ns1__ValueListItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TypeDescription:
		((ns1__TypeDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Structure:
		((ns1__Structure *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StringQualifiers:
		((ns1__StringQualifiers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StandardPeriod:
		((ns1__StandardPeriod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StandardBeginningDate:
		((ns1__StandardBeginningDate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NumberQualifiers:
		((ns1__NumberQualifiers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Map:
		((ns1__Map *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LocalStringType:
		((ns1__LocalStringType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LocalStringItemType:
		((ns1__LocalStringItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__KeyAndValue:
		((ns1__KeyAndValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenericException:
		((ns1__GenericException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FixedStructure:
		((ns1__FixedStructure *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FixedMap:
		((ns1__FixedMap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FixedArray:
		((ns1__FixedArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Exception:
		((ns1__Exception *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DateQualifiers:
		((ns1__DateQualifiers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DataFillErrors:
		((ns1__DataFillErrors *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DataFillError:
		((ns1__DataFillError *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BinaryDataQualifiers:
		((ns1__BinaryDataQualifiers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Array:
		((ns1__Array *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__NMTOKEN:
		soap_serialize_xsd__NMTOKEN(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns1__MozaicAuthorization_:
		soap_serialize___ns1__MozaicAuthorization_(soap, (const struct __ns1__MozaicAuthorization_ *)ptr);
		break;
	case SOAP_TYPE___ns1__СинхронизацияСправочнойИнформации_:
		soap_serialize___ns1__СинхронизацияСправочнойИнформации_(soap, (const struct __ns1__СинхронизацияСправочнойИнформации_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ВыгрузкаСправочнойИнформации_:
		soap_serialize___ns1__ВыгрузкаСправочнойИнформации_(soap, (const struct __ns1__ВыгрузкаСправочнойИнформации_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ПринятьПакетОбмена_:
		soap_serialize___ns1__ПринятьПакетОбмена_(soap, (const struct __ns1__ПринятьПакетОбмена_ *)ptr);
		break;
	case SOAP_TYPE___ns1__MozaicAuthorization:
		soap_serialize___ns1__MozaicAuthorization(soap, (const struct __ns1__MozaicAuthorization *)ptr);
		break;
	case SOAP_TYPE___ns1__СинхронизацияСправочнойИнформации:
		soap_serialize___ns1__СинхронизацияСправочнойИнформации(soap, (const struct __ns1__СинхронизацияСправочнойИнформации *)ptr);
		break;
	case SOAP_TYPE___ns1__ВыгрузкаСправочнойИнформации:
		soap_serialize___ns1__ВыгрузкаСправочнойИнформации(soap, (const struct __ns1__ВыгрузкаСправочнойИнформации *)ptr);
		break;
	case SOAP_TYPE___ns1__ПринятьПакетОбмена:
		soap_serialize___ns1__ПринятьПакетОбмена(soap, (const struct __ns1__ПринятьПакетОбмена *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__MozaicAuthorization:
		soap_serialize_PointerTo_ns1__MozaicAuthorization(soap, (_ns1__MozaicAuthorization *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__СинхронизацияСправочнойИнформации:
		soap_serialize_PointerTo_ns1__СинхронизацияСправочнойИнформации(soap, (_ns1__СинхронизацияСправочнойИнформации *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ВыгрузкаСправочнойИнформации:
		soap_serialize_PointerTo_ns1__ВыгрузкаСправочнойИнформации(soap, (_ns1__ВыгрузкаСправочнойИнформации *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ПринятьПакетОбмена:
		soap_serialize_PointerTo_ns1__ПринятьПакетОбмена(soap, (_ns1__ПринятьПакетОбмена *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ValueStorage:
		soap_serialize_PointerTons1__ValueStorage(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ValueTreeRow:
		soap_serialize_PointerTons1__ValueTreeRow(soap, (ns1__ValueTreeRow *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ValueTreeColumn:
		soap_serialize_PointerTons1__ValueTreeColumn(soap, (ns1__ValueTreeColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		soap_serialize_PointerToxsd__nonNegativeInteger(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__NMTOKEN:
		soap_serialize_PointerToxsd__NMTOKEN(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ValueTableRow:
		soap_serialize_PointerTons1__ValueTableRow(soap, (ns1__ValueTableRow *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ValueTableIndex:
		soap_serialize_PointerTons1__ValueTableIndex(soap, (ns1__ValueTableIndex *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ValueTableColumn:
		soap_serialize_PointerTons1__ValueTableColumn(soap, (ns1__ValueTableColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ValueListItemType:
		soap_serialize_PointerTons1__ValueListItemType(soap, (ns1__ValueListItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ValueListType:
		soap_serialize_PointerTons1__ValueListType(soap, (ns1__ValueListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TypeDescription:
		soap_serialize_PointerTons1__TypeDescription(soap, (ns1__TypeDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__decimal:
		soap_serialize_PointerToxsd__decimal(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BinaryDataQualifiers:
		soap_serialize_PointerTons1__BinaryDataQualifiers(soap, (ns1__BinaryDataQualifiers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DateQualifiers:
		soap_serialize_PointerTons1__DateQualifiers(soap, (ns1__DateQualifiers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StringQualifiers:
		soap_serialize_PointerTons1__StringQualifiers(soap, (ns1__StringQualifiers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NumberQualifiers:
		soap_serialize_PointerTons1__NumberQualifiers(soap, (ns1__NumberQualifiers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodateTime:
		soap_serialize_PointerTodateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LocalStringItemType:
		soap_serialize_PointerTons1__LocalStringItemType(soap, (ns1__LocalStringItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenericException:
		soap_serialize_PointerTons1__GenericException(soap, (ns1__GenericException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__KeyAndValue:
		soap_serialize_PointerTons1__KeyAndValue(soap, (ns1__KeyAndValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DataFillError:
		soap_serialize_PointerTons1__DataFillError(soap, (ns1__DataFillError *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Array:
		return (void*)soap_instantiate_ns1__Array(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BinaryDataQualifiers:
		return (void*)soap_instantiate_ns1__BinaryDataQualifiers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DataFillError:
		return (void*)soap_instantiate_ns1__DataFillError(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DataFillErrors:
		return (void*)soap_instantiate_ns1__DataFillErrors(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DateQualifiers:
		return (void*)soap_instantiate_ns1__DateQualifiers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FixedArray:
		return (void*)soap_instantiate_ns1__FixedArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FixedMap:
		return (void*)soap_instantiate_ns1__FixedMap(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__FixedStructure_Property:
		return (void*)soap_instantiate__ns1__FixedStructure_Property(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FixedStructure:
		return (void*)soap_instantiate_ns1__FixedStructure(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenericException:
		return (void*)soap_instantiate_ns1__GenericException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__KeyAndValue:
		return (void*)soap_instantiate_ns1__KeyAndValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LocalStringItemType:
		return (void*)soap_instantiate_ns1__LocalStringItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LocalStringType:
		return (void*)soap_instantiate_ns1__LocalStringType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Map:
		return (void*)soap_instantiate_ns1__Map(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NumberQualifiers:
		return (void*)soap_instantiate_ns1__NumberQualifiers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StandardBeginningDate:
		return (void*)soap_instantiate_ns1__StandardBeginningDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StandardPeriod:
		return (void*)soap_instantiate_ns1__StandardPeriod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StringQualifiers:
		return (void*)soap_instantiate_ns1__StringQualifiers(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Structure_Property:
		return (void*)soap_instantiate__ns1__Structure_Property(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Structure:
		return (void*)soap_instantiate_ns1__Structure(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TypeDescription:
		return (void*)soap_instantiate_ns1__TypeDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ValueListItemType:
		return (void*)soap_instantiate_ns1__ValueListItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ValueListType:
		return (void*)soap_instantiate_ns1__ValueListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ValueTable:
		return (void*)soap_instantiate_ns1__ValueTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ValueTableColumn:
		return (void*)soap_instantiate_ns1__ValueTableColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ValueTableIndex:
		return (void*)soap_instantiate_ns1__ValueTableIndex(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ValueTableRow:
		return (void*)soap_instantiate_ns1__ValueTableRow(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ValueTree:
		return (void*)soap_instantiate_ns1__ValueTree(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ValueTreeColumn:
		return (void*)soap_instantiate_ns1__ValueTreeColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ValueTreeRow:
		return (void*)soap_instantiate_ns1__ValueTreeRow(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ПринятьПакетОбмена:
		return (void*)soap_instantiate__ns1__ПринятьПакетОбмена(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ПринятьПакетОбменаResponse:
		return (void*)soap_instantiate__ns1__ПринятьПакетОбменаResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации:
		return (void*)soap_instantiate__ns1__ВыгрузкаСправочнойИнформации(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформацииResponse:
		return (void*)soap_instantiate__ns1__ВыгрузкаСправочнойИнформацииResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации:
		return (void*)soap_instantiate__ns1__СинхронизацияСправочнойИнформации(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__СинхронизацияСправочнойИнформацииResponse:
		return (void*)soap_instantiate__ns1__СинхронизацияСправочнойИнформацииResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__MozaicAuthorization:
		return (void*)soap_instantiate__ns1__MozaicAuthorization(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__MozaicAuthorizationResponse:
		return (void*)soap_instantiate__ns1__MozaicAuthorizationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Exception:
		return (void*)soap_instantiate_ns1__Exception(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ПринятьПакетОбмена:
		return (void*)soap_instantiate___ns1__ПринятьПакетОбмена(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ВыгрузкаСправочнойИнформации:
		return (void*)soap_instantiate___ns1__ВыгрузкаСправочнойИнформации(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__СинхронизацияСправочнойИнформации:
		return (void*)soap_instantiate___ns1__СинхронизацияСправочнойИнформации(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__MozaicAuthorization:
		return (void*)soap_instantiate___ns1__MozaicAuthorization(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ПринятьПакетОбмена_:
		return (void*)soap_instantiate___ns1__ПринятьПакетОбмена_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ВыгрузкаСправочнойИнформации_:
		return (void*)soap_instantiate___ns1__ВыгрузкаСправочнойИнформации_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__СинхронизацияСправочнойИнформации_:
		return (void*)soap_instantiate___ns1__СинхронизацияСправочнойИнформации_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__MozaicAuthorization_:
		return (void*)soap_instantiate___ns1__MozaicAuthorization_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NMTOKEN:
		return (void*)soap_instantiate_xsd__NMTOKEN(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CompositeID:
		return (void*)soap_instantiate_ns1__CompositeID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Null:
		return (void*)soap_instantiate_ns1__Null(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ObjectVersion:
		return (void*)soap_instantiate_ns1__ObjectVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Type:
		return (void*)soap_instantiate_ns1__Type(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UUID:
		return (void*)soap_instantiate_ns1__UUID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ValueStorage:
		return (void*)soap_instantiate_ns1__ValueStorage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTreeRow:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTreeRow(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTreeColumn:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTreeColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__NMTOKEN:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__NMTOKEN(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableRow:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTableRow(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableIndex:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTableIndex(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableColumn:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTableColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueListItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ValueListItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns1__UUID:
		return (void*)soap_instantiate_std__vectorTemplateOfns1__UUID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns1__Structure_Property:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns1__Structure_Property(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__LocalStringItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__LocalStringItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_ns1__FixedStructure_Property:
		return (void*)soap_instantiate_std__vectorTemplateOf_ns1__FixedStructure_Property(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__KeyAndValue:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__KeyAndValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataFillError:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__DataFillError(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		break;
	case SOAP_TYPE_ns1__Array:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Array*>(p->ptr), ns1__Array);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Array*>(p->ptr), ns1__Array);
		break;
	case SOAP_TYPE_ns1__BinaryDataQualifiers:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__BinaryDataQualifiers*>(p->ptr), ns1__BinaryDataQualifiers);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__BinaryDataQualifiers*>(p->ptr), ns1__BinaryDataQualifiers);
		break;
	case SOAP_TYPE_ns1__DataFillError:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DataFillError*>(p->ptr), ns1__DataFillError);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DataFillError*>(p->ptr), ns1__DataFillError);
		break;
	case SOAP_TYPE_ns1__DataFillErrors:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DataFillErrors*>(p->ptr), ns1__DataFillErrors);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DataFillErrors*>(p->ptr), ns1__DataFillErrors);
		break;
	case SOAP_TYPE_ns1__DateQualifiers:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DateQualifiers*>(p->ptr), ns1__DateQualifiers);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DateQualifiers*>(p->ptr), ns1__DateQualifiers);
		break;
	case SOAP_TYPE_ns1__FixedArray:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FixedArray*>(p->ptr), ns1__FixedArray);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FixedArray*>(p->ptr), ns1__FixedArray);
		break;
	case SOAP_TYPE_ns1__FixedMap:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FixedMap*>(p->ptr), ns1__FixedMap);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FixedMap*>(p->ptr), ns1__FixedMap);
		break;
	case SOAP_TYPE__ns1__FixedStructure_Property:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__FixedStructure_Property*>(p->ptr), _ns1__FixedStructure_Property);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__FixedStructure_Property*>(p->ptr), _ns1__FixedStructure_Property);
		break;
	case SOAP_TYPE_ns1__FixedStructure:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FixedStructure*>(p->ptr), ns1__FixedStructure);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FixedStructure*>(p->ptr), ns1__FixedStructure);
		break;
	case SOAP_TYPE_ns1__GenericException:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__GenericException*>(p->ptr), ns1__GenericException);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__GenericException*>(p->ptr), ns1__GenericException);
		break;
	case SOAP_TYPE_ns1__KeyAndValue:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__KeyAndValue*>(p->ptr), ns1__KeyAndValue);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__KeyAndValue*>(p->ptr), ns1__KeyAndValue);
		break;
	case SOAP_TYPE_ns1__LocalStringItemType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__LocalStringItemType*>(p->ptr), ns1__LocalStringItemType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__LocalStringItemType*>(p->ptr), ns1__LocalStringItemType);
		break;
	case SOAP_TYPE_ns1__LocalStringType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__LocalStringType*>(p->ptr), ns1__LocalStringType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__LocalStringType*>(p->ptr), ns1__LocalStringType);
		break;
	case SOAP_TYPE_ns1__Map:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Map*>(p->ptr), ns1__Map);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Map*>(p->ptr), ns1__Map);
		break;
	case SOAP_TYPE_ns1__NumberQualifiers:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__NumberQualifiers*>(p->ptr), ns1__NumberQualifiers);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__NumberQualifiers*>(p->ptr), ns1__NumberQualifiers);
		break;
	case SOAP_TYPE_ns1__StandardBeginningDate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__StandardBeginningDate*>(p->ptr), ns1__StandardBeginningDate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__StandardBeginningDate*>(p->ptr), ns1__StandardBeginningDate);
		break;
	case SOAP_TYPE_ns1__StandardPeriod:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__StandardPeriod*>(p->ptr), ns1__StandardPeriod);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__StandardPeriod*>(p->ptr), ns1__StandardPeriod);
		break;
	case SOAP_TYPE_ns1__StringQualifiers:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__StringQualifiers*>(p->ptr), ns1__StringQualifiers);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__StringQualifiers*>(p->ptr), ns1__StringQualifiers);
		break;
	case SOAP_TYPE__ns1__Structure_Property:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Structure_Property*>(p->ptr), _ns1__Structure_Property);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Structure_Property*>(p->ptr), _ns1__Structure_Property);
		break;
	case SOAP_TYPE_ns1__Structure:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Structure*>(p->ptr), ns1__Structure);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Structure*>(p->ptr), ns1__Structure);
		break;
	case SOAP_TYPE_ns1__TypeDescription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TypeDescription*>(p->ptr), ns1__TypeDescription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TypeDescription*>(p->ptr), ns1__TypeDescription);
		break;
	case SOAP_TYPE_ns1__ValueListItemType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ValueListItemType*>(p->ptr), ns1__ValueListItemType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ValueListItemType*>(p->ptr), ns1__ValueListItemType);
		break;
	case SOAP_TYPE_ns1__ValueListType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ValueListType*>(p->ptr), ns1__ValueListType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ValueListType*>(p->ptr), ns1__ValueListType);
		break;
	case SOAP_TYPE_ns1__ValueTable:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ValueTable*>(p->ptr), ns1__ValueTable);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ValueTable*>(p->ptr), ns1__ValueTable);
		break;
	case SOAP_TYPE_ns1__ValueTableColumn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ValueTableColumn*>(p->ptr), ns1__ValueTableColumn);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ValueTableColumn*>(p->ptr), ns1__ValueTableColumn);
		break;
	case SOAP_TYPE_ns1__ValueTableIndex:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ValueTableIndex*>(p->ptr), ns1__ValueTableIndex);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ValueTableIndex*>(p->ptr), ns1__ValueTableIndex);
		break;
	case SOAP_TYPE_ns1__ValueTableRow:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ValueTableRow*>(p->ptr), ns1__ValueTableRow);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ValueTableRow*>(p->ptr), ns1__ValueTableRow);
		break;
	case SOAP_TYPE_ns1__ValueTree:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ValueTree*>(p->ptr), ns1__ValueTree);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ValueTree*>(p->ptr), ns1__ValueTree);
		break;
	case SOAP_TYPE_ns1__ValueTreeColumn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ValueTreeColumn*>(p->ptr), ns1__ValueTreeColumn);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ValueTreeColumn*>(p->ptr), ns1__ValueTreeColumn);
		break;
	case SOAP_TYPE_ns1__ValueTreeRow:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ValueTreeRow*>(p->ptr), ns1__ValueTreeRow);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ValueTreeRow*>(p->ptr), ns1__ValueTreeRow);
		break;
	case SOAP_TYPE__ns1__ПринятьПакетОбмена:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ПринятьПакетОбмена*>(p->ptr), _ns1__ПринятьПакетОбмена);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ПринятьПакетОбмена*>(p->ptr), _ns1__ПринятьПакетОбмена);
		break;
	case SOAP_TYPE__ns1__ПринятьПакетОбменаResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ПринятьПакетОбменаResponse*>(p->ptr), _ns1__ПринятьПакетОбменаResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ПринятьПакетОбменаResponse*>(p->ptr), _ns1__ПринятьПакетОбменаResponse);
		break;
	case SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ВыгрузкаСправочнойИнформации*>(p->ptr), _ns1__ВыгрузкаСправочнойИнформации);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ВыгрузкаСправочнойИнформации*>(p->ptr), _ns1__ВыгрузкаСправочнойИнформации);
		break;
	case SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформацииResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ВыгрузкаСправочнойИнформацииResponse*>(p->ptr), _ns1__ВыгрузкаСправочнойИнформацииResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ВыгрузкаСправочнойИнформацииResponse*>(p->ptr), _ns1__ВыгрузкаСправочнойИнформацииResponse);
		break;
	case SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__СинхронизацияСправочнойИнформации*>(p->ptr), _ns1__СинхронизацияСправочнойИнформации);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__СинхронизацияСправочнойИнформации*>(p->ptr), _ns1__СинхронизацияСправочнойИнформации);
		break;
	case SOAP_TYPE__ns1__СинхронизацияСправочнойИнформацииResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__СинхронизацияСправочнойИнформацииResponse*>(p->ptr), _ns1__СинхронизацияСправочнойИнформацииResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__СинхронизацияСправочнойИнформацииResponse*>(p->ptr), _ns1__СинхронизацияСправочнойИнформацииResponse);
		break;
	case SOAP_TYPE__ns1__MozaicAuthorization:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__MozaicAuthorization*>(p->ptr), _ns1__MozaicAuthorization);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__MozaicAuthorization*>(p->ptr), _ns1__MozaicAuthorization);
		break;
	case SOAP_TYPE__ns1__MozaicAuthorizationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__MozaicAuthorizationResponse*>(p->ptr), _ns1__MozaicAuthorizationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__MozaicAuthorizationResponse*>(p->ptr), _ns1__MozaicAuthorizationResponse);
		break;
	case SOAP_TYPE_ns1__Exception:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Exception*>(p->ptr), ns1__Exception);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Exception*>(p->ptr), ns1__Exception);
		break;
	case SOAP_TYPE___ns1__ПринятьПакетОбмена:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ПринятьПакетОбмена*>(p->ptr), struct __ns1__ПринятьПакетОбмена);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ПринятьПакетОбмена*>(p->ptr), struct __ns1__ПринятьПакетОбмена);
		break;
	case SOAP_TYPE___ns1__ВыгрузкаСправочнойИнформации:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ВыгрузкаСправочнойИнформации*>(p->ptr), struct __ns1__ВыгрузкаСправочнойИнформации);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ВыгрузкаСправочнойИнформации*>(p->ptr), struct __ns1__ВыгрузкаСправочнойИнформации);
		break;
	case SOAP_TYPE___ns1__СинхронизацияСправочнойИнформации:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__СинхронизацияСправочнойИнформации*>(p->ptr), struct __ns1__СинхронизацияСправочнойИнформации);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__СинхронизацияСправочнойИнформации*>(p->ptr), struct __ns1__СинхронизацияСправочнойИнформации);
		break;
	case SOAP_TYPE___ns1__MozaicAuthorization:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__MozaicAuthorization*>(p->ptr), struct __ns1__MozaicAuthorization);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__MozaicAuthorization*>(p->ptr), struct __ns1__MozaicAuthorization);
		break;
	case SOAP_TYPE___ns1__ПринятьПакетОбмена_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ПринятьПакетОбмена_*>(p->ptr), struct __ns1__ПринятьПакетОбмена_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ПринятьПакетОбмена_*>(p->ptr), struct __ns1__ПринятьПакетОбмена_);
		break;
	case SOAP_TYPE___ns1__ВыгрузкаСправочнойИнформации_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ВыгрузкаСправочнойИнформации_*>(p->ptr), struct __ns1__ВыгрузкаСправочнойИнформации_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ВыгрузкаСправочнойИнформации_*>(p->ptr), struct __ns1__ВыгрузкаСправочнойИнформации_);
		break;
	case SOAP_TYPE___ns1__СинхронизацияСправочнойИнформации_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__СинхронизацияСправочнойИнформации_*>(p->ptr), struct __ns1__СинхронизацияСправочнойИнформации_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__СинхронизацияСправочнойИнформации_*>(p->ptr), struct __ns1__СинхронизацияСправочнойИнформации_);
		break;
	case SOAP_TYPE___ns1__MozaicAuthorization_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__MozaicAuthorization_*>(p->ptr), struct __ns1__MozaicAuthorization_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__MozaicAuthorization_*>(p->ptr), struct __ns1__MozaicAuthorization_);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__NMTOKEN:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__CompositeID:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Null:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ObjectVersion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__Type:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__UUID:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__ValueStorage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTreeRow:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__ValueTreeRow *> *>(p->ptr), std::vector<ns1__ValueTreeRow *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__ValueTreeRow *> *>(p->ptr), std::vector<ns1__ValueTreeRow *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTreeColumn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__ValueTreeColumn *> *>(p->ptr), std::vector<ns1__ValueTreeColumn *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__ValueTreeColumn *> *>(p->ptr), std::vector<ns1__ValueTreeColumn *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__NMTOKEN:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableRow:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__ValueTableRow *> *>(p->ptr), std::vector<ns1__ValueTableRow *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__ValueTableRow *> *>(p->ptr), std::vector<ns1__ValueTableRow *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableIndex:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__ValueTableIndex *> *>(p->ptr), std::vector<ns1__ValueTableIndex *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__ValueTableIndex *> *>(p->ptr), std::vector<ns1__ValueTableIndex *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableColumn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__ValueTableColumn *> *>(p->ptr), std::vector<ns1__ValueTableColumn *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__ValueTableColumn *> *>(p->ptr), std::vector<ns1__ValueTableColumn *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueListItemType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__ValueListItemType *> *>(p->ptr), std::vector<ns1__ValueListItemType *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__ValueListItemType *> *>(p->ptr), std::vector<ns1__ValueListItemType *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__UUID:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns1__Structure_Property:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_ns1__Structure_Property> *>(p->ptr), std::vector<_ns1__Structure_Property> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_ns1__Structure_Property> *>(p->ptr), std::vector<_ns1__Structure_Property> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__LocalStringItemType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__LocalStringItemType *> *>(p->ptr), std::vector<ns1__LocalStringItemType *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__LocalStringItemType *> *>(p->ptr), std::vector<ns1__LocalStringItemType *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns1__FixedStructure_Property:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<_ns1__FixedStructure_Property> *>(p->ptr), std::vector<_ns1__FixedStructure_Property> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<_ns1__FixedStructure_Property> *>(p->ptr), std::vector<_ns1__FixedStructure_Property> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__KeyAndValue:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__KeyAndValue *> *>(p->ptr), std::vector<ns1__KeyAndValue *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__KeyAndValue *> *>(p->ptr), std::vector<ns1__KeyAndValue *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataFillError:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__DataFillError *> *>(p->ptr), std::vector<ns1__DataFillError *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__DataFillError *> *>(p->ptr), std::vector<ns1__DataFillError *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<char *> *>(p->ptr), std::vector<char *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<char *> *>(p->ptr), std::vector<char *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{

		case SOAP_TYPE_ns1__Exception: t = SOAP_TYPE_ns1__GenericException; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTreeRow:
		if (t == SOAP_TYPE_ns1__ValueTreeRow || soap_fbase(t, SOAP_TYPE_ns1__ValueTreeRow))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__ValueTreeRow *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__ValueTreeRow *> *)p)[index] = *(ns1__ValueTreeRow **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTreeColumn:
		if (t == SOAP_TYPE_ns1__ValueTreeColumn || soap_fbase(t, SOAP_TYPE_ns1__ValueTreeColumn))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__ValueTreeColumn *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__ValueTreeColumn *> *)p)[index] = *(ns1__ValueTreeColumn **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__NMTOKEN:
		if (t == SOAP_TYPE_xsd__NMTOKEN)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableRow:
		if (t == SOAP_TYPE_ns1__ValueTableRow || soap_fbase(t, SOAP_TYPE_ns1__ValueTableRow))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__ValueTableRow *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__ValueTableRow *> *)p)[index] = *(ns1__ValueTableRow **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableIndex:
		if (t == SOAP_TYPE_ns1__ValueTableIndex || soap_fbase(t, SOAP_TYPE_ns1__ValueTableIndex))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__ValueTableIndex *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__ValueTableIndex *> *)p)[index] = *(ns1__ValueTableIndex **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableColumn:
		if (t == SOAP_TYPE_ns1__ValueTableColumn || soap_fbase(t, SOAP_TYPE_ns1__ValueTableColumn))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__ValueTableColumn *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__ValueTableColumn *> *)p)[index] = *(ns1__ValueTableColumn **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueListItemType:
		if (t == SOAP_TYPE_ns1__ValueListItemType || soap_fbase(t, SOAP_TYPE_ns1__ValueListItemType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__ValueListItemType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__ValueListItemType *> *)p)[index] = *(ns1__ValueListItemType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__UUID:
		if (t == SOAP_TYPE_ns1__UUID)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		if (t == SOAP_TYPE_xsd__QName)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns1__Structure_Property:
		if (t == SOAP_TYPE__ns1__Structure_Property)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_ns1__Structure_Property>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_ns1__Structure_Property> *)p)[index] = *(_ns1__Structure_Property *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__LocalStringItemType:
		if (t == SOAP_TYPE_ns1__LocalStringItemType || soap_fbase(t, SOAP_TYPE_ns1__LocalStringItemType))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__LocalStringItemType *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__LocalStringItemType *> *)p)[index] = *(ns1__LocalStringItemType **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_ns1__FixedStructure_Property:
		if (t == SOAP_TYPE__ns1__FixedStructure_Property)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<_ns1__FixedStructure_Property>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<_ns1__FixedStructure_Property> *)p)[index] = *(_ns1__FixedStructure_Property *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__KeyAndValue:
		if (t == SOAP_TYPE_ns1__KeyAndValue || soap_fbase(t, SOAP_TYPE_ns1__KeyAndValue))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__KeyAndValue *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__KeyAndValue *> *)p)[index] = *(ns1__KeyAndValue **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataFillError:
		if (t == SOAP_TYPE_ns1__DataFillError || soap_fbase(t, SOAP_TYPE_ns1__DataFillError))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__DataFillError *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__DataFillError *> *)p)[index] = *(ns1__DataFillError **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (t == SOAP_TYPE__XML)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<char *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<char *> *)p)[index] = *(char **)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__base64Binary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE_ns1__Array:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Array type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Array*)p = *(ns1__Array*)q;
		break;
	case SOAP_TYPE_ns1__BinaryDataQualifiers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__BinaryDataQualifiers type=%d location=%p object=%p\n", t, p, q));
		*(ns1__BinaryDataQualifiers*)p = *(ns1__BinaryDataQualifiers*)q;
		break;
	case SOAP_TYPE_ns1__DataFillError:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DataFillError type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DataFillError*)p = *(ns1__DataFillError*)q;
		break;
	case SOAP_TYPE_ns1__DataFillErrors:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DataFillErrors type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DataFillErrors*)p = *(ns1__DataFillErrors*)q;
		break;
	case SOAP_TYPE_ns1__DateQualifiers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DateQualifiers type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DateQualifiers*)p = *(ns1__DateQualifiers*)q;
		break;
	case SOAP_TYPE_ns1__FixedArray:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FixedArray type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FixedArray*)p = *(ns1__FixedArray*)q;
		break;
	case SOAP_TYPE_ns1__FixedMap:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FixedMap type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FixedMap*)p = *(ns1__FixedMap*)q;
		break;
	case SOAP_TYPE__ns1__FixedStructure_Property:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__FixedStructure_Property type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__FixedStructure_Property*)p = *(_ns1__FixedStructure_Property*)q;
		break;
	case SOAP_TYPE_ns1__FixedStructure:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FixedStructure type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FixedStructure*)p = *(ns1__FixedStructure*)q;
		break;
	case SOAP_TYPE_ns1__GenericException:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__GenericException type=%d location=%p object=%p\n", t, p, q));
		*(ns1__GenericException*)p = *(ns1__GenericException*)q;
		break;
	case SOAP_TYPE_ns1__KeyAndValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__KeyAndValue type=%d location=%p object=%p\n", t, p, q));
		*(ns1__KeyAndValue*)p = *(ns1__KeyAndValue*)q;
		break;
	case SOAP_TYPE_ns1__LocalStringItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__LocalStringItemType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__LocalStringItemType*)p = *(ns1__LocalStringItemType*)q;
		break;
	case SOAP_TYPE_ns1__LocalStringType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__LocalStringType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__LocalStringType*)p = *(ns1__LocalStringType*)q;
		break;
	case SOAP_TYPE_ns1__Map:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Map type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Map*)p = *(ns1__Map*)q;
		break;
	case SOAP_TYPE_ns1__NumberQualifiers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__NumberQualifiers type=%d location=%p object=%p\n", t, p, q));
		*(ns1__NumberQualifiers*)p = *(ns1__NumberQualifiers*)q;
		break;
	case SOAP_TYPE_ns1__StandardBeginningDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__StandardBeginningDate type=%d location=%p object=%p\n", t, p, q));
		*(ns1__StandardBeginningDate*)p = *(ns1__StandardBeginningDate*)q;
		break;
	case SOAP_TYPE_ns1__StandardPeriod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__StandardPeriod type=%d location=%p object=%p\n", t, p, q));
		*(ns1__StandardPeriod*)p = *(ns1__StandardPeriod*)q;
		break;
	case SOAP_TYPE_ns1__StringQualifiers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__StringQualifiers type=%d location=%p object=%p\n", t, p, q));
		*(ns1__StringQualifiers*)p = *(ns1__StringQualifiers*)q;
		break;
	case SOAP_TYPE__ns1__Structure_Property:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Structure_Property type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Structure_Property*)p = *(_ns1__Structure_Property*)q;
		break;
	case SOAP_TYPE_ns1__Structure:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Structure type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Structure*)p = *(ns1__Structure*)q;
		break;
	case SOAP_TYPE_ns1__TypeDescription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TypeDescription type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TypeDescription*)p = *(ns1__TypeDescription*)q;
		break;
	case SOAP_TYPE_ns1__ValueListItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ValueListItemType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ValueListItemType*)p = *(ns1__ValueListItemType*)q;
		break;
	case SOAP_TYPE__ns1__union_ValueListType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_ValueListType type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_ValueListType*)p = *(union _ns1__union_ValueListType*)q;
		break;
	case SOAP_TYPE_ns1__ValueListType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ValueListType type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ValueListType*)p = *(ns1__ValueListType*)q;
		break;
	case SOAP_TYPE_ns1__ValueTable:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ValueTable type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ValueTable*)p = *(ns1__ValueTable*)q;
		break;
	case SOAP_TYPE_ns1__ValueTableColumn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ValueTableColumn type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ValueTableColumn*)p = *(ns1__ValueTableColumn*)q;
		break;
	case SOAP_TYPE_ns1__ValueTableIndex:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ValueTableIndex type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ValueTableIndex*)p = *(ns1__ValueTableIndex*)q;
		break;
	case SOAP_TYPE_ns1__ValueTableRow:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ValueTableRow type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ValueTableRow*)p = *(ns1__ValueTableRow*)q;
		break;
	case SOAP_TYPE_ns1__ValueTree:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ValueTree type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ValueTree*)p = *(ns1__ValueTree*)q;
		break;
	case SOAP_TYPE_ns1__ValueTreeColumn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ValueTreeColumn type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ValueTreeColumn*)p = *(ns1__ValueTreeColumn*)q;
		break;
	case SOAP_TYPE_ns1__ValueTreeRow:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ValueTreeRow type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ValueTreeRow*)p = *(ns1__ValueTreeRow*)q;
		break;
	case SOAP_TYPE__ns1__ПринятьПакетОбмена:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ПринятьПакетОбмена type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ПринятьПакетОбмена*)p = *(_ns1__ПринятьПакетОбмена*)q;
		break;
	case SOAP_TYPE__ns1__ПринятьПакетОбменаResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ПринятьПакетОбменаResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ПринятьПакетОбменаResponse*)p = *(_ns1__ПринятьПакетОбменаResponse*)q;
		break;
	case SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ВыгрузкаСправочнойИнформации type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ВыгрузкаСправочнойИнформации*)p = *(_ns1__ВыгрузкаСправочнойИнформации*)q;
		break;
	case SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформацииResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ВыгрузкаСправочнойИнформацииResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ВыгрузкаСправочнойИнформацииResponse*)p = *(_ns1__ВыгрузкаСправочнойИнформацииResponse*)q;
		break;
	case SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__СинхронизацияСправочнойИнформации type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__СинхронизацияСправочнойИнформации*)p = *(_ns1__СинхронизацияСправочнойИнформации*)q;
		break;
	case SOAP_TYPE__ns1__СинхронизацияСправочнойИнформацииResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__СинхронизацияСправочнойИнформацииResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__СинхронизацияСправочнойИнформацииResponse*)p = *(_ns1__СинхронизацияСправочнойИнформацииResponse*)q;
		break;
	case SOAP_TYPE__ns1__MozaicAuthorization:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__MozaicAuthorization type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__MozaicAuthorization*)p = *(_ns1__MozaicAuthorization*)q;
		break;
	case SOAP_TYPE__ns1__MozaicAuthorizationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__MozaicAuthorizationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__MozaicAuthorizationResponse*)p = *(_ns1__MozaicAuthorizationResponse*)q;
		break;
	case SOAP_TYPE_ns1__Exception:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Exception type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Exception*)p = *(ns1__Exception*)q;
		break;
	case SOAP_TYPE___ns1__ПринятьПакетОбмена:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ПринятьПакетОбмена type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ПринятьПакетОбмена*)p = *(struct __ns1__ПринятьПакетОбмена*)q;
		break;
	case SOAP_TYPE___ns1__ВыгрузкаСправочнойИнформации:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ВыгрузкаСправочнойИнформации type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ВыгрузкаСправочнойИнформации*)p = *(struct __ns1__ВыгрузкаСправочнойИнформации*)q;
		break;
	case SOAP_TYPE___ns1__СинхронизацияСправочнойИнформации:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__СинхронизацияСправочнойИнформации type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__СинхронизацияСправочнойИнформации*)p = *(struct __ns1__СинхронизацияСправочнойИнформации*)q;
		break;
	case SOAP_TYPE___ns1__MozaicAuthorization:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__MozaicAuthorization type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__MozaicAuthorization*)p = *(struct __ns1__MozaicAuthorization*)q;
		break;
	case SOAP_TYPE___ns1__ПринятьПакетОбмена_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ПринятьПакетОбмена_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ПринятьПакетОбмена_*)p = *(struct __ns1__ПринятьПакетОбмена_*)q;
		break;
	case SOAP_TYPE___ns1__ВыгрузкаСправочнойИнформации_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ВыгрузкаСправочнойИнформации_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ВыгрузкаСправочнойИнформации_*)p = *(struct __ns1__ВыгрузкаСправочнойИнформации_*)q;
		break;
	case SOAP_TYPE___ns1__СинхронизацияСправочнойИнформации_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__СинхронизацияСправочнойИнформации_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__СинхронизацияСправочнойИнформации_*)p = *(struct __ns1__СинхронизацияСправочнойИнформации_*)q;
		break;
	case SOAP_TYPE___ns1__MozaicAuthorization_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__MozaicAuthorization_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__MozaicAuthorization_*)p = *(struct __ns1__MozaicAuthorization_*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__QName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__NMTOKEN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__decimal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__CompositeID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Null:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ObjectVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Type:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__UUID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__ValueStorage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return a;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_new_LONG64(struct soap *soap, int n)
{
	LONG64 *a = static_cast<LONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(LONG64)));
	for (LONG64 *p = a; p && n--; ++p)
		soap_default_LONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_LONG64(soap, tag ? tag : "long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n)
{
	unsigned char *a = static_cast<unsigned char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned char)));
	for (unsigned char *p = a; p && n--; ++p)
		soap_default_unsignedByte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *a = static_cast<unsigned int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned int)));
	for (unsigned int *p = a; p && n--; ++p)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__StandardPeriodVariant[] =
{	{ (LONG64)ns1__StandardPeriodVariant__Custom, "Custom" },
	{ (LONG64)ns1__StandardPeriodVariant__Today, "Today" },
	{ (LONG64)ns1__StandardPeriodVariant__ThisWeek, "ThisWeek" },
	{ (LONG64)ns1__StandardPeriodVariant__ThisTenDays, "ThisTenDays" },
	{ (LONG64)ns1__StandardPeriodVariant__ThisMonth, "ThisMonth" },
	{ (LONG64)ns1__StandardPeriodVariant__ThisQuarter, "ThisQuarter" },
	{ (LONG64)ns1__StandardPeriodVariant__ThisHalfYear, "ThisHalfYear" },
	{ (LONG64)ns1__StandardPeriodVariant__ThisYear, "ThisYear" },
	{ (LONG64)ns1__StandardPeriodVariant__FromBeginningOfThisWeek, "FromBeginningOfThisWeek" },
	{ (LONG64)ns1__StandardPeriodVariant__FromBeginningOfThisTenDays, "FromBeginningOfThisTenDays" },
	{ (LONG64)ns1__StandardPeriodVariant__FromBeginningOfThisMonth, "FromBeginningOfThisMonth" },
	{ (LONG64)ns1__StandardPeriodVariant__FromBeginningOfThisQuarter, "FromBeginningOfThisQuarter" },
	{ (LONG64)ns1__StandardPeriodVariant__FromBeginningOfThisHalfYear, "FromBeginningOfThisHalfYear" },
	{ (LONG64)ns1__StandardPeriodVariant__FromBeginningOfThisYear, "FromBeginningOfThisYear" },
	{ (LONG64)ns1__StandardPeriodVariant__Yesterday, "Yesterday" },
	{ (LONG64)ns1__StandardPeriodVariant__LastWeek, "LastWeek" },
	{ (LONG64)ns1__StandardPeriodVariant__LastTenDays, "LastTenDays" },
	{ (LONG64)ns1__StandardPeriodVariant__LastMonth, "LastMonth" },
	{ (LONG64)ns1__StandardPeriodVariant__LastQuarter, "LastQuarter" },
	{ (LONG64)ns1__StandardPeriodVariant__LastHalfYear, "LastHalfYear" },
	{ (LONG64)ns1__StandardPeriodVariant__LastYear, "LastYear" },
	{ (LONG64)ns1__StandardPeriodVariant__LastWeekTillSameWeekDay, "LastWeekTillSameWeekDay" },
	{ (LONG64)ns1__StandardPeriodVariant__LastTenDaysTillSameDayNumber, "LastTenDaysTillSameDayNumber" },
	{ (LONG64)ns1__StandardPeriodVariant__LastMonthTillSameDate, "LastMonthTillSameDate" },
	{ (LONG64)ns1__StandardPeriodVariant__LastQuarterTillSameDate, "LastQuarterTillSameDate" },
	{ (LONG64)ns1__StandardPeriodVariant__LastHalfYearTillSameDate, "LastHalfYearTillSameDate" },
	{ (LONG64)ns1__StandardPeriodVariant__LastYearTillSameDate, "LastYearTillSameDate" },
	{ (LONG64)ns1__StandardPeriodVariant__Tomorrow, "Tomorrow" },
	{ (LONG64)ns1__StandardPeriodVariant__NextWeek, "NextWeek" },
	{ (LONG64)ns1__StandardPeriodVariant__NextTenDays, "NextTenDays" },
	{ (LONG64)ns1__StandardPeriodVariant__NextMonth, "NextMonth" },
	{ (LONG64)ns1__StandardPeriodVariant__NextQuarter, "NextQuarter" },
	{ (LONG64)ns1__StandardPeriodVariant__NextHalfYear, "NextHalfYear" },
	{ (LONG64)ns1__StandardPeriodVariant__NextYear, "NextYear" },
	{ (LONG64)ns1__StandardPeriodVariant__NextWeekTillSameWeekDay, "NextWeekTillSameWeekDay" },
	{ (LONG64)ns1__StandardPeriodVariant__NextTenDaysTillSameDayNumber, "NextTenDaysTillSameDayNumber" },
	{ (LONG64)ns1__StandardPeriodVariant__NextMonthTillSameDate, "NextMonthTillSameDate" },
	{ (LONG64)ns1__StandardPeriodVariant__NextQuarterTillSameDate, "NextQuarterTillSameDate" },
	{ (LONG64)ns1__StandardPeriodVariant__NextHalfYearTillSameDate, "NextHalfYearTillSameDate" },
	{ (LONG64)ns1__StandardPeriodVariant__NextYearTillSameDate, "NextYearTillSameDate" },
	{ (LONG64)ns1__StandardPeriodVariant__TillEndOfThisWeek, "TillEndOfThisWeek" },
	{ (LONG64)ns1__StandardPeriodVariant__TillEndOfThisTenDays, "TillEndOfThisTenDays" },
	{ (LONG64)ns1__StandardPeriodVariant__TillEndOfThisMonth, "TillEndOfThisMonth" },
	{ (LONG64)ns1__StandardPeriodVariant__TillEndOfThisQuarter, "TillEndOfThisQuarter" },
	{ (LONG64)ns1__StandardPeriodVariant__TillEndOfThisHalfYear, "TillEndOfThisHalfYear" },
	{ (LONG64)ns1__StandardPeriodVariant__TillEndOfThisYear, "TillEndOfThisYear" },
	{ (LONG64)ns1__StandardPeriodVariant__Last7Days, "Last7Days" },
	{ (LONG64)ns1__StandardPeriodVariant__Next7Days, "Next7Days" },
	{ (LONG64)ns1__StandardPeriodVariant__Month, "Month" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__StandardPeriodVariant2s(struct soap *soap, enum ns1__StandardPeriodVariant n)
{
	const char *s = soap_code_str(soap_codes_ns1__StandardPeriodVariant, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StandardPeriodVariant(struct soap *soap, const char *tag, int id, const enum ns1__StandardPeriodVariant *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StandardPeriodVariant), type) || soap_send(soap, soap_ns1__StandardPeriodVariant2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__StandardPeriodVariant(struct soap *soap, const char *s, enum ns1__StandardPeriodVariant *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__StandardPeriodVariant, s);
	if (map)
		*a = (enum ns1__StandardPeriodVariant)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 48)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__StandardPeriodVariant)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__StandardPeriodVariant * SOAP_FMAC4 soap_in_ns1__StandardPeriodVariant(struct soap *soap, const char *tag, enum ns1__StandardPeriodVariant *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__StandardPeriodVariant*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StandardPeriodVariant, sizeof(enum ns1__StandardPeriodVariant), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__StandardPeriodVariant(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__StandardPeriodVariant *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StandardPeriodVariant, SOAP_TYPE_ns1__StandardPeriodVariant, sizeof(enum ns1__StandardPeriodVariant), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__StandardPeriodVariant * SOAP_FMAC4 soap_new_ns1__StandardPeriodVariant(struct soap *soap, int n)
{
	enum ns1__StandardPeriodVariant *a = static_cast<enum ns1__StandardPeriodVariant *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__StandardPeriodVariant)));
	for (enum ns1__StandardPeriodVariant *p = a; p && n--; ++p)
		soap_default_ns1__StandardPeriodVariant(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__StandardPeriodVariant(struct soap *soap, const enum ns1__StandardPeriodVariant *a, const char *tag, const char *type)
{
	if (soap_out_ns1__StandardPeriodVariant(soap, tag ? tag : "ns1:StandardPeriodVariant", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__StandardPeriodVariant * SOAP_FMAC4 soap_get_ns1__StandardPeriodVariant(struct soap *soap, enum ns1__StandardPeriodVariant *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StandardPeriodVariant(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__StandardBeginningDateVariant[] =
{	{ (LONG64)ns1__StandardBeginningDateVariant__Custom, "Custom" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfThisDay, "BeginningOfThisDay" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfThisWeek, "BeginningOfThisWeek" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfThisTenDays, "BeginningOfThisTenDays" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfThisMonth, "BeginningOfThisMonth" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfThisQuarter, "BeginningOfThisQuarter" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfThisHalfYear, "BeginningOfThisHalfYear" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfThisYear, "BeginningOfThisYear" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfLastDay, "BeginningOfLastDay" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfLastWeek, "BeginningOfLastWeek" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfLastTenDays, "BeginningOfLastTenDays" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfLastMonth, "BeginningOfLastMonth" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfLastQuarter, "BeginningOfLastQuarter" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfLastHalfYear, "BeginningOfLastHalfYear" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfLastYear, "BeginningOfLastYear" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfNextDay, "BeginningOfNextDay" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfNextWeek, "BeginningOfNextWeek" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfNextTenDays, "BeginningOfNextTenDays" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfNextMonth, "BeginningOfNextMonth" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfNextQuarter, "BeginningOfNextQuarter" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfNextHalfYear, "BeginningOfNextHalfYear" },
	{ (LONG64)ns1__StandardBeginningDateVariant__BeginningOfNextYear, "BeginningOfNextYear" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__StandardBeginningDateVariant2s(struct soap *soap, enum ns1__StandardBeginningDateVariant n)
{
	const char *s = soap_code_str(soap_codes_ns1__StandardBeginningDateVariant, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StandardBeginningDateVariant(struct soap *soap, const char *tag, int id, const enum ns1__StandardBeginningDateVariant *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StandardBeginningDateVariant), type) || soap_send(soap, soap_ns1__StandardBeginningDateVariant2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__StandardBeginningDateVariant(struct soap *soap, const char *s, enum ns1__StandardBeginningDateVariant *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__StandardBeginningDateVariant, s);
	if (map)
		*a = (enum ns1__StandardBeginningDateVariant)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 21)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__StandardBeginningDateVariant)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__StandardBeginningDateVariant * SOAP_FMAC4 soap_in_ns1__StandardBeginningDateVariant(struct soap *soap, const char *tag, enum ns1__StandardBeginningDateVariant *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__StandardBeginningDateVariant*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StandardBeginningDateVariant, sizeof(enum ns1__StandardBeginningDateVariant), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__StandardBeginningDateVariant(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__StandardBeginningDateVariant *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StandardBeginningDateVariant, SOAP_TYPE_ns1__StandardBeginningDateVariant, sizeof(enum ns1__StandardBeginningDateVariant), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__StandardBeginningDateVariant * SOAP_FMAC4 soap_new_ns1__StandardBeginningDateVariant(struct soap *soap, int n)
{
	enum ns1__StandardBeginningDateVariant *a = static_cast<enum ns1__StandardBeginningDateVariant *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__StandardBeginningDateVariant)));
	for (enum ns1__StandardBeginningDateVariant *p = a; p && n--; ++p)
		soap_default_ns1__StandardBeginningDateVariant(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__StandardBeginningDateVariant(struct soap *soap, const enum ns1__StandardBeginningDateVariant *a, const char *tag, const char *type)
{
	if (soap_out_ns1__StandardBeginningDateVariant(soap, tag ? tag : "ns1:StandardBeginningDateVariant", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__StandardBeginningDateVariant * SOAP_FMAC4 soap_get_ns1__StandardBeginningDateVariant(struct soap *soap, enum ns1__StandardBeginningDateVariant *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StandardBeginningDateVariant(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__MainClientApplicationWindowMode[] =
{	{ (LONG64)ns1__MainClientApplicationWindowMode__Normal, "Normal" },
	{ (LONG64)ns1__MainClientApplicationWindowMode__Workplace, "Workplace" },
	{ (LONG64)ns1__MainClientApplicationWindowMode__FullscreenWorkplace, "FullscreenWorkplace" },
	{ (LONG64)ns1__MainClientApplicationWindowMode__Kiosk, "Kiosk" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__MainClientApplicationWindowMode2s(struct soap *soap, enum ns1__MainClientApplicationWindowMode n)
{
	const char *s = soap_code_str(soap_codes_ns1__MainClientApplicationWindowMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MainClientApplicationWindowMode(struct soap *soap, const char *tag, int id, const enum ns1__MainClientApplicationWindowMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MainClientApplicationWindowMode), type) || soap_send(soap, soap_ns1__MainClientApplicationWindowMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__MainClientApplicationWindowMode(struct soap *soap, const char *s, enum ns1__MainClientApplicationWindowMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__MainClientApplicationWindowMode, s);
	if (map)
		*a = (enum ns1__MainClientApplicationWindowMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__MainClientApplicationWindowMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__MainClientApplicationWindowMode * SOAP_FMAC4 soap_in_ns1__MainClientApplicationWindowMode(struct soap *soap, const char *tag, enum ns1__MainClientApplicationWindowMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__MainClientApplicationWindowMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MainClientApplicationWindowMode, sizeof(enum ns1__MainClientApplicationWindowMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__MainClientApplicationWindowMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__MainClientApplicationWindowMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MainClientApplicationWindowMode, SOAP_TYPE_ns1__MainClientApplicationWindowMode, sizeof(enum ns1__MainClientApplicationWindowMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__MainClientApplicationWindowMode * SOAP_FMAC4 soap_new_ns1__MainClientApplicationWindowMode(struct soap *soap, int n)
{
	enum ns1__MainClientApplicationWindowMode *a = static_cast<enum ns1__MainClientApplicationWindowMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__MainClientApplicationWindowMode)));
	for (enum ns1__MainClientApplicationWindowMode *p = a; p && n--; ++p)
		soap_default_ns1__MainClientApplicationWindowMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MainClientApplicationWindowMode(struct soap *soap, const enum ns1__MainClientApplicationWindowMode *a, const char *tag, const char *type)
{
	if (soap_out_ns1__MainClientApplicationWindowMode(soap, tag ? tag : "ns1:MainClientApplicationWindowMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__MainClientApplicationWindowMode * SOAP_FMAC4 soap_get_ns1__MainClientApplicationWindowMode(struct soap *soap, enum ns1__MainClientApplicationWindowMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MainClientApplicationWindowMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__FillChecking[] =
{	{ (LONG64)ns1__FillChecking__DontCheck, "DontCheck" },
	{ (LONG64)ns1__FillChecking__ShowError, "ShowError" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__FillChecking2s(struct soap *soap, enum ns1__FillChecking n)
{
	const char *s = soap_code_str(soap_codes_ns1__FillChecking, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FillChecking(struct soap *soap, const char *tag, int id, const enum ns1__FillChecking *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FillChecking), type) || soap_send(soap, soap_ns1__FillChecking2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__FillChecking(struct soap *soap, const char *s, enum ns1__FillChecking *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__FillChecking, s);
	if (map)
		*a = (enum ns1__FillChecking)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__FillChecking)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__FillChecking * SOAP_FMAC4 soap_in_ns1__FillChecking(struct soap *soap, const char *tag, enum ns1__FillChecking *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__FillChecking*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FillChecking, sizeof(enum ns1__FillChecking), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__FillChecking(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__FillChecking *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FillChecking, SOAP_TYPE_ns1__FillChecking, sizeof(enum ns1__FillChecking), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__FillChecking * SOAP_FMAC4 soap_new_ns1__FillChecking(struct soap *soap, int n)
{
	enum ns1__FillChecking *a = static_cast<enum ns1__FillChecking *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__FillChecking)));
	for (enum ns1__FillChecking *p = a; p && n--; ++p)
		soap_default_ns1__FillChecking(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__FillChecking(struct soap *soap, const enum ns1__FillChecking *a, const char *tag, const char *type)
{
	if (soap_out_ns1__FillChecking(soap, tag ? tag : "ns1:FillChecking", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__FillChecking * SOAP_FMAC4 soap_get_ns1__FillChecking(struct soap *soap, enum ns1__FillChecking *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FillChecking(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__FillCheckErrorStatus[] =
{	{ (LONG64)ns1__FillCheckErrorStatus__Error, "Error" },
	{ (LONG64)ns1__FillCheckErrorStatus__Warning, "Warning" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__FillCheckErrorStatus2s(struct soap *soap, enum ns1__FillCheckErrorStatus n)
{
	const char *s = soap_code_str(soap_codes_ns1__FillCheckErrorStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FillCheckErrorStatus(struct soap *soap, const char *tag, int id, const enum ns1__FillCheckErrorStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FillCheckErrorStatus), type) || soap_send(soap, soap_ns1__FillCheckErrorStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__FillCheckErrorStatus(struct soap *soap, const char *s, enum ns1__FillCheckErrorStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__FillCheckErrorStatus, s);
	if (map)
		*a = (enum ns1__FillCheckErrorStatus)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__FillCheckErrorStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__FillCheckErrorStatus * SOAP_FMAC4 soap_in_ns1__FillCheckErrorStatus(struct soap *soap, const char *tag, enum ns1__FillCheckErrorStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__FillCheckErrorStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FillCheckErrorStatus, sizeof(enum ns1__FillCheckErrorStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__FillCheckErrorStatus(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__FillCheckErrorStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FillCheckErrorStatus, SOAP_TYPE_ns1__FillCheckErrorStatus, sizeof(enum ns1__FillCheckErrorStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__FillCheckErrorStatus * SOAP_FMAC4 soap_new_ns1__FillCheckErrorStatus(struct soap *soap, int n)
{
	enum ns1__FillCheckErrorStatus *a = static_cast<enum ns1__FillCheckErrorStatus *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__FillCheckErrorStatus)));
	for (enum ns1__FillCheckErrorStatus *p = a; p && n--; ++p)
		soap_default_ns1__FillCheckErrorStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__FillCheckErrorStatus(struct soap *soap, const enum ns1__FillCheckErrorStatus *a, const char *tag, const char *type)
{
	if (soap_out_ns1__FillCheckErrorStatus(soap, tag ? tag : "ns1:FillCheckErrorStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__FillCheckErrorStatus * SOAP_FMAC4 soap_get_ns1__FillCheckErrorStatus(struct soap *soap, enum ns1__FillCheckErrorStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FillCheckErrorStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__DateFractions[] =
{	{ (LONG64)ns1__DateFractions__Date, "Date" },
	{ (LONG64)ns1__DateFractions__Time, "Time" },
	{ (LONG64)ns1__DateFractions__DateTime, "DateTime" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__DateFractions2s(struct soap *soap, enum ns1__DateFractions n)
{
	const char *s = soap_code_str(soap_codes_ns1__DateFractions, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DateFractions(struct soap *soap, const char *tag, int id, const enum ns1__DateFractions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DateFractions), type) || soap_send(soap, soap_ns1__DateFractions2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__DateFractions(struct soap *soap, const char *s, enum ns1__DateFractions *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__DateFractions, s);
	if (map)
		*a = (enum ns1__DateFractions)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__DateFractions)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DateFractions * SOAP_FMAC4 soap_in_ns1__DateFractions(struct soap *soap, const char *tag, enum ns1__DateFractions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__DateFractions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DateFractions, sizeof(enum ns1__DateFractions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__DateFractions(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__DateFractions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DateFractions, SOAP_TYPE_ns1__DateFractions, sizeof(enum ns1__DateFractions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__DateFractions * SOAP_FMAC4 soap_new_ns1__DateFractions(struct soap *soap, int n)
{
	enum ns1__DateFractions *a = static_cast<enum ns1__DateFractions *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__DateFractions)));
	for (enum ns1__DateFractions *p = a; p && n--; ++p)
		soap_default_ns1__DateFractions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DateFractions(struct soap *soap, const enum ns1__DateFractions *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DateFractions(soap, tag ? tag : "ns1:DateFractions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DateFractions * SOAP_FMAC4 soap_get_ns1__DateFractions(struct soap *soap, enum ns1__DateFractions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DateFractions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__AllowedSign[] =
{	{ (LONG64)ns1__AllowedSign__Any, "Any" },
	{ (LONG64)ns1__AllowedSign__Nonnegative, "Nonnegative" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__AllowedSign2s(struct soap *soap, enum ns1__AllowedSign n)
{
	const char *s = soap_code_str(soap_codes_ns1__AllowedSign, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AllowedSign(struct soap *soap, const char *tag, int id, const enum ns1__AllowedSign *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AllowedSign), type) || soap_send(soap, soap_ns1__AllowedSign2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__AllowedSign(struct soap *soap, const char *s, enum ns1__AllowedSign *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__AllowedSign, s);
	if (map)
		*a = (enum ns1__AllowedSign)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__AllowedSign)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__AllowedSign * SOAP_FMAC4 soap_in_ns1__AllowedSign(struct soap *soap, const char *tag, enum ns1__AllowedSign *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__AllowedSign*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AllowedSign, sizeof(enum ns1__AllowedSign), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__AllowedSign(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__AllowedSign *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AllowedSign, SOAP_TYPE_ns1__AllowedSign, sizeof(enum ns1__AllowedSign), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__AllowedSign * SOAP_FMAC4 soap_new_ns1__AllowedSign(struct soap *soap, int n)
{
	enum ns1__AllowedSign *a = static_cast<enum ns1__AllowedSign *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__AllowedSign)));
	for (enum ns1__AllowedSign *p = a; p && n--; ++p)
		soap_default_ns1__AllowedSign(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AllowedSign(struct soap *soap, const enum ns1__AllowedSign *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AllowedSign(soap, tag ? tag : "ns1:AllowedSign", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__AllowedSign * SOAP_FMAC4 soap_get_ns1__AllowedSign(struct soap *soap, enum ns1__AllowedSign *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AllowedSign(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__AllowedLength[] =
{	{ (LONG64)ns1__AllowedLength__Fixed, "Fixed" },
	{ (LONG64)ns1__AllowedLength__Variable, "Variable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__AllowedLength2s(struct soap *soap, enum ns1__AllowedLength n)
{
	const char *s = soap_code_str(soap_codes_ns1__AllowedLength, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AllowedLength(struct soap *soap, const char *tag, int id, const enum ns1__AllowedLength *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AllowedLength), type) || soap_send(soap, soap_ns1__AllowedLength2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__AllowedLength(struct soap *soap, const char *s, enum ns1__AllowedLength *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__AllowedLength, s);
	if (map)
		*a = (enum ns1__AllowedLength)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__AllowedLength)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__AllowedLength * SOAP_FMAC4 soap_in_ns1__AllowedLength(struct soap *soap, const char *tag, enum ns1__AllowedLength *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__AllowedLength*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AllowedLength, sizeof(enum ns1__AllowedLength), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__AllowedLength(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__AllowedLength *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AllowedLength, SOAP_TYPE_ns1__AllowedLength, sizeof(enum ns1__AllowedLength), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__AllowedLength * SOAP_FMAC4 soap_new_ns1__AllowedLength(struct soap *soap, int n)
{
	enum ns1__AllowedLength *a = static_cast<enum ns1__AllowedLength *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__AllowedLength)));
	for (enum ns1__AllowedLength *p = a; p && n--; ++p)
		soap_default_ns1__AllowedLength(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AllowedLength(struct soap *soap, const enum ns1__AllowedLength *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AllowedLength(soap, tag ? tag : "ns1:AllowedLength", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__AllowedLength * SOAP_FMAC4 soap_get_ns1__AllowedLength(struct soap *soap, enum ns1__AllowedLength *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AllowedLength(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Structure_Property::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__Structure_Property::Value = NULL;
	soap_default_xsd__NMTOKEN(soap, &this->_ns1__Structure_Property::name);
}

void _ns1__Structure_Property::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__Structure_Property::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Structure_Property(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Structure_Property(struct soap *soap, const char *tag, int id, const _ns1__Structure_Property *a, const char *type)
{
	soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((_ns1__Structure_Property*)a)->name), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Structure_Property), type))
		return soap->error;
	if (!a->_ns1__Structure_Property::Value)
	{	if (soap_element_nil(soap, "ns1:Value"))
			return soap->error;
	}
	else if (soap_outliteral(soap, "ns1:Value", (char*const*)&a->_ns1__Structure_Property::Value, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Structure_Property::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__Structure_Property(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Structure_Property * SOAP_FMAC4 soap_in__ns1__Structure_Property(struct soap *soap, const char *tag, _ns1__Structure_Property *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Structure_Property*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Structure_Property, sizeof(_ns1__Structure_Property), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Structure_Property)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Structure_Property *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 1), &((_ns1__Structure_Property*)a)->name))
		return NULL;
	size_t soap_flag_Value1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns1:Value", (char**)&a->_ns1__Structure_Property::Value))
				{	soap_flag_Value1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Value1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__Structure_Property *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Structure_Property, SOAP_TYPE__ns1__Structure_Property, sizeof(_ns1__Structure_Property), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Structure_Property * SOAP_FMAC2 soap_instantiate__ns1__Structure_Property(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Structure_Property(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Structure_Property *p;
	size_t k = sizeof(_ns1__Structure_Property);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__Structure_Property, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Structure_Property);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Structure_Property, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Structure_Property location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Structure_Property::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Structure_Property(soap, tag ? tag : "ns1:Structure-Property", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Structure_Property::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Structure_Property(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Structure_Property * SOAP_FMAC4 soap_get__ns1__Structure_Property(struct soap *soap, _ns1__Structure_Property *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Structure_Property(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__FixedStructure_Property::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__FixedStructure_Property::Value = NULL;
	soap_default_xsd__NMTOKEN(soap, &this->_ns1__FixedStructure_Property::name);
}

void _ns1__FixedStructure_Property::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__FixedStructure_Property::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__FixedStructure_Property(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FixedStructure_Property(struct soap *soap, const char *tag, int id, const _ns1__FixedStructure_Property *a, const char *type)
{
	soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((_ns1__FixedStructure_Property*)a)->name), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__FixedStructure_Property), type))
		return soap->error;
	if (!a->_ns1__FixedStructure_Property::Value)
	{	if (soap_element_nil(soap, "ns1:Value"))
			return soap->error;
	}
	else if (soap_outliteral(soap, "ns1:Value", (char*const*)&a->_ns1__FixedStructure_Property::Value, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__FixedStructure_Property::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__FixedStructure_Property(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__FixedStructure_Property * SOAP_FMAC4 soap_in__ns1__FixedStructure_Property(struct soap *soap, const char *tag, _ns1__FixedStructure_Property *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__FixedStructure_Property*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__FixedStructure_Property, sizeof(_ns1__FixedStructure_Property), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__FixedStructure_Property)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__FixedStructure_Property *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 1), &((_ns1__FixedStructure_Property*)a)->name))
		return NULL;
	size_t soap_flag_Value1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns1:Value", (char**)&a->_ns1__FixedStructure_Property::Value))
				{	soap_flag_Value1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Value1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__FixedStructure_Property *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__FixedStructure_Property, SOAP_TYPE__ns1__FixedStructure_Property, sizeof(_ns1__FixedStructure_Property), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__FixedStructure_Property * SOAP_FMAC2 soap_instantiate__ns1__FixedStructure_Property(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__FixedStructure_Property(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__FixedStructure_Property *p;
	size_t k = sizeof(_ns1__FixedStructure_Property);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__FixedStructure_Property, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__FixedStructure_Property);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__FixedStructure_Property, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__FixedStructure_Property location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__FixedStructure_Property::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__FixedStructure_Property(soap, tag ? tag : "ns1:FixedStructure-Property", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__FixedStructure_Property::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__FixedStructure_Property(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__FixedStructure_Property * SOAP_FMAC4 soap_get__ns1__FixedStructure_Property(struct soap *soap, _ns1__FixedStructure_Property *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FixedStructure_Property(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ValueStorage(struct soap *soap, xsd__base64Binary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ValueStorage(struct soap *soap, const xsd__base64Binary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_attachment_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_ns1__ValueStorage, a->id, a->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ValueStorage2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ValueStorage(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_ns1__ValueStorage);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_ns1__ValueStorage, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ValueStorage(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_ns1__ValueStorage(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ValueStorage, sizeof(xsd__base64Binary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ValueStorage, SOAP_TYPE_ns1__ValueStorage, sizeof(xsd__base64Binary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ValueStorage(struct soap *soap, const xsd__base64Binary *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ValueStorage(soap, tag ? tag : "ns1:ValueStorage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_ns1__ValueStorage(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ValueStorage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UUID(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UUID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__UUID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__UUID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__UUID, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__UUID, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__UUID, SOAP_TYPE_ns1__UUID, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UUID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UUID(soap, tag ? tag : "ns1:UUID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__UUID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UUID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ObjectVersion(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ObjectVersion(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__ObjectVersion), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__ObjectVersion(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ObjectVersion, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[0-9a-fA-F]{40}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__ObjectVersion, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__ObjectVersion, SOAP_TYPE_ns1__ObjectVersion, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ObjectVersion(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ObjectVersion(soap, tag ? tag : "ns1:ObjectVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__ObjectVersion(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ObjectVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Null(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Null(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__Null), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__Null(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Null, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 0, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__Null, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__Null, SOAP_TYPE_ns1__Null, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Null(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Null(soap, tag ? tag : "ns1:Null", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__Null(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Null(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__CompositeID(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CompositeID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns1__CompositeID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns1__CompositeID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__CompositeID, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "-?[0-9]+(:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})?")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns1__CompositeID, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns1__CompositeID, SOAP_TYPE_ns1__CompositeID, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CompositeID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_ns1__CompositeID(soap, tag ? tag : "ns1:CompositeID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns1__CompositeID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CompositeID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__MozaicAuthorizationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__MozaicAuthorizationResponse::return_ = NULL;
}

void _ns1__MozaicAuthorizationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__MozaicAuthorizationResponse::return_);
#endif
}

int _ns1__MozaicAuthorizationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MozaicAuthorizationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MozaicAuthorizationResponse(struct soap *soap, const char *tag, int id, const _ns1__MozaicAuthorizationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MozaicAuthorizationResponse), type))
		return soap->error;
	if (a->return_)
		soap_element_result(soap, "ns1:return");
	if (!a->_ns1__MozaicAuthorizationResponse::return_)
	{	if (soap_element_nil(soap, "ns1:return"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns1:return", -1, &a->_ns1__MozaicAuthorizationResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MozaicAuthorizationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__MozaicAuthorizationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MozaicAuthorizationResponse * SOAP_FMAC4 soap_in__ns1__MozaicAuthorizationResponse(struct soap *soap, const char *tag, _ns1__MozaicAuthorizationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MozaicAuthorizationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MozaicAuthorizationResponse, sizeof(_ns1__MozaicAuthorizationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__MozaicAuthorizationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__MozaicAuthorizationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:return", &a->_ns1__MozaicAuthorizationResponse::return_, "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:return");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__MozaicAuthorizationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MozaicAuthorizationResponse, SOAP_TYPE__ns1__MozaicAuthorizationResponse, sizeof(_ns1__MozaicAuthorizationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__MozaicAuthorizationResponse * SOAP_FMAC2 soap_instantiate__ns1__MozaicAuthorizationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MozaicAuthorizationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__MozaicAuthorizationResponse *p;
	size_t k = sizeof(_ns1__MozaicAuthorizationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__MozaicAuthorizationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__MozaicAuthorizationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__MozaicAuthorizationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__MozaicAuthorizationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__MozaicAuthorizationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__MozaicAuthorizationResponse(soap, tag ? tag : "ns1:MozaicAuthorizationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MozaicAuthorizationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MozaicAuthorizationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MozaicAuthorizationResponse * SOAP_FMAC4 soap_get__ns1__MozaicAuthorizationResponse(struct soap *soap, _ns1__MozaicAuthorizationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MozaicAuthorizationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__MozaicAuthorization::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _ns1__MozaicAuthorization::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__MozaicAuthorization::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MozaicAuthorization(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MozaicAuthorization(struct soap *soap, const char *tag, int id, const _ns1__MozaicAuthorization *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MozaicAuthorization), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MozaicAuthorization::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__MozaicAuthorization(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MozaicAuthorization * SOAP_FMAC4 soap_in__ns1__MozaicAuthorization(struct soap *soap, const char *tag, _ns1__MozaicAuthorization *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MozaicAuthorization*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MozaicAuthorization, sizeof(_ns1__MozaicAuthorization), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__MozaicAuthorization)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__MozaicAuthorization *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__MozaicAuthorization *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MozaicAuthorization, SOAP_TYPE__ns1__MozaicAuthorization, sizeof(_ns1__MozaicAuthorization), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__MozaicAuthorization * SOAP_FMAC2 soap_instantiate__ns1__MozaicAuthorization(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MozaicAuthorization(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__MozaicAuthorization *p;
	size_t k = sizeof(_ns1__MozaicAuthorization);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__MozaicAuthorization, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__MozaicAuthorization);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__MozaicAuthorization, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__MozaicAuthorization location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__MozaicAuthorization::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__MozaicAuthorization(soap, tag ? tag : "ns1:MozaicAuthorization", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MozaicAuthorization::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MozaicAuthorization(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MozaicAuthorization * SOAP_FMAC4 soap_get__ns1__MozaicAuthorization(struct soap *soap, _ns1__MozaicAuthorization *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MozaicAuthorization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__СинхронизацияСправочнойИнформацииResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__СинхронизацияСправочнойИнформацииResponse::return_ = NULL;
}

void _ns1__СинхронизацияСправочнойИнформацииResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ValueStorage(soap, &this->_ns1__СинхронизацияСправочнойИнформацииResponse::return_);
#endif
}

int _ns1__СинхронизацияСправочнойИнформацииResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__СинхронизацияСправочнойИнформацииResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__СинхронизацияСправочнойИнформацииResponse(struct soap *soap, const char *tag, int id, const _ns1__СинхронизацияСправочнойИнформацииResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__СинхронизацияСправочнойИнформацииResponse), type))
		return soap->error;
	if (a->return_)
		soap_element_result(soap, "ns1:return");
	if (!a->_ns1__СинхронизацияСправочнойИнформацииResponse::return_)
	{	if (soap_element_nil(soap, "ns1:return"))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ValueStorage(soap, "ns1:return", -1, &a->_ns1__СинхронизацияСправочнойИнформацииResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__СинхронизацияСправочнойИнформацииResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__СинхронизацияСправочнойИнформацииResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__СинхронизацияСправочнойИнформацииResponse * SOAP_FMAC4 soap_in__ns1__СинхронизацияСправочнойИнформацииResponse(struct soap *soap, const char *tag, _ns1__СинхронизацияСправочнойИнформацииResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__СинхронизацияСправочнойИнформацииResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__СинхронизацияСправочнойИнформацииResponse, sizeof(_ns1__СинхронизацияСправочнойИнформацииResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__СинхронизацияСправочнойИнформацииResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__СинхронизацияСправочнойИнформацииResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ValueStorage(soap, "ns1:return", &a->_ns1__СинхронизацияСправочнойИнформацииResponse::return_, "ns1:ValueStorage"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:return");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__СинхронизацияСправочнойИнформацииResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__СинхронизацияСправочнойИнформацииResponse, SOAP_TYPE__ns1__СинхронизацияСправочнойИнформацииResponse, sizeof(_ns1__СинхронизацияСправочнойИнформацииResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__СинхронизацияСправочнойИнформацииResponse * SOAP_FMAC2 soap_instantiate__ns1__СинхронизацияСправочнойИнформацииResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__СинхронизацияСправочнойИнформацииResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__СинхронизацияСправочнойИнформацииResponse *p;
	size_t k = sizeof(_ns1__СинхронизацияСправочнойИнформацииResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__СинхронизацияСправочнойИнформацииResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__СинхронизацияСправочнойИнформацииResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__СинхронизацияСправочнойИнформацииResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__СинхронизацияСправочнойИнформацииResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__СинхронизацияСправочнойИнформацииResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__СинхронизацияСправочнойИнформацииResponse(soap, tag ? tag : "ns1:СинхронизацияСправочнойИнформацииResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__СинхронизацияСправочнойИнформацииResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__СинхронизацияСправочнойИнформацииResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__СинхронизацияСправочнойИнформацииResponse * SOAP_FMAC4 soap_get__ns1__СинхронизацияСправочнойИнформацииResponse(struct soap *soap, _ns1__СинхронизацияСправочнойИнформацииResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__СинхронизацияСправочнойИнформацииResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__СинхронизацияСправочнойИнформации::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__СинхронизацияСправочнойИнформации::_ТекстЗапроса = NULL;
	this->_ns1__СинхронизацияСправочнойИнформации::_ОжидатьЗавершения = NULL;
}

void _ns1__СинхронизацияСправочнойИнформации::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ValueStorage(soap, &this->_ns1__СинхронизацияСправочнойИнформации::_ТекстЗапроса);
	soap_serialize_PointerToxsd__decimal(soap, &this->_ns1__СинхронизацияСправочнойИнформации::_ОжидатьЗавершения);
#endif
}

int _ns1__СинхронизацияСправочнойИнформации::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__СинхронизацияСправочнойИнформации(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__СинхронизацияСправочнойИнформации(struct soap *soap, const char *tag, int id, const _ns1__СинхронизацияСправочнойИнформации *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации), type))
		return soap->error;
	if (!a->_ns1__СинхронизацияСправочнойИнформации::_ТекстЗапроса)
	{	if (soap_element_nil(soap, "ns1:ТекстЗапроса"))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ValueStorage(soap, "ns1:ТекстЗапроса", -1, &a->_ns1__СинхронизацияСправочнойИнформации::_ТекстЗапроса, ""))
		return soap->error;
	if (!a->_ns1__СинхронизацияСправочнойИнформации::_ОжидатьЗавершения)
	{	if (soap_element_nil(soap, "ns1:ОжидатьЗавершения"))
			return soap->error;
	}
	else if (soap_out_PointerToxsd__decimal(soap, "ns1:ОжидатьЗавершения", -1, &a->_ns1__СинхронизацияСправочнойИнформации::_ОжидатьЗавершения, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__СинхронизацияСправочнойИнформации::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__СинхронизацияСправочнойИнформации(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__СинхронизацияСправочнойИнформации * SOAP_FMAC4 soap_in__ns1__СинхронизацияСправочнойИнформации(struct soap *soap, const char *tag, _ns1__СинхронизацияСправочнойИнформации *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__СинхронизацияСправочнойИнформации*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации, sizeof(_ns1__СинхронизацияСправочнойИнформации), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__СинхронизацияСправочнойИнформации *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag__ТекстЗапроса1 = 1;
	size_t soap_flag__ОжидатьЗавершения1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__ТекстЗапроса1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ValueStorage(soap, NULL, &a->_ns1__СинхронизацияСправочнойИнформации::_ТекстЗапроса, "ns1:ValueStorage"))
				{	soap_flag__ТекстЗапроса1--;
					continue;
				}
			}
			if (soap_flag__ОжидатьЗавершения1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__decimal(soap, NULL, &a->_ns1__СинхронизацияСправочнойИнформации::_ОжидатьЗавершения, "xsd:decimal"))
				{	soap_flag__ОжидатьЗавершения1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__ТекстЗапроса1 > 0 || soap_flag__ОжидатьЗавершения1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__СинхронизацияСправочнойИнформации *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации, SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации, sizeof(_ns1__СинхронизацияСправочнойИнформации), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__СинхронизацияСправочнойИнформации * SOAP_FMAC2 soap_instantiate__ns1__СинхронизацияСправочнойИнформации(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__СинхронизацияСправочнойИнформации(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__СинхронизацияСправочнойИнформации *p;
	size_t k = sizeof(_ns1__СинхронизацияСправочнойИнформации);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__СинхронизацияСправочнойИнформации);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__СинхронизацияСправочнойИнформации, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__СинхронизацияСправочнойИнформации location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__СинхронизацияСправочнойИнформации::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__СинхронизацияСправочнойИнформации(soap, tag ? tag : "ns1:СинхронизацияСправочнойИнформации", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__СинхронизацияСправочнойИнформации::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__СинхронизацияСправочнойИнформации(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__СинхронизацияСправочнойИнформации * SOAP_FMAC4 soap_get__ns1__СинхронизацияСправочнойИнформации(struct soap *soap, _ns1__СинхронизацияСправочнойИнформации *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__СинхронизацияСправочнойИнформации(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ВыгрузкаСправочнойИнформацииResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ВыгрузкаСправочнойИнформацииResponse::return_ = NULL;
}

void _ns1__ВыгрузкаСправочнойИнформацииResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ValueStorage(soap, &this->_ns1__ВыгрузкаСправочнойИнформацииResponse::return_);
#endif
}

int _ns1__ВыгрузкаСправочнойИнформацииResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ВыгрузкаСправочнойИнформацииResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ВыгрузкаСправочнойИнформацииResponse(struct soap *soap, const char *tag, int id, const _ns1__ВыгрузкаСправочнойИнформацииResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформацииResponse), type))
		return soap->error;
	if (a->return_)
		soap_element_result(soap, "ns1:return");
	if (!a->_ns1__ВыгрузкаСправочнойИнформацииResponse::return_)
	{	if (soap_element_nil(soap, "ns1:return"))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ValueStorage(soap, "ns1:return", -1, &a->_ns1__ВыгрузкаСправочнойИнформацииResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ВыгрузкаСправочнойИнформацииResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__ВыгрузкаСправочнойИнформацииResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ВыгрузкаСправочнойИнформацииResponse * SOAP_FMAC4 soap_in__ns1__ВыгрузкаСправочнойИнформацииResponse(struct soap *soap, const char *tag, _ns1__ВыгрузкаСправочнойИнформацииResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ВыгрузкаСправочнойИнформацииResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформацииResponse, sizeof(_ns1__ВыгрузкаСправочнойИнформацииResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформацииResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ВыгрузкаСправочнойИнформацииResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ValueStorage(soap, "ns1:return", &a->_ns1__ВыгрузкаСправочнойИнформацииResponse::return_, "ns1:ValueStorage"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:return");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ВыгрузкаСправочнойИнформацииResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформацииResponse, SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформацииResponse, sizeof(_ns1__ВыгрузкаСправочнойИнформацииResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ВыгрузкаСправочнойИнформацииResponse * SOAP_FMAC2 soap_instantiate__ns1__ВыгрузкаСправочнойИнформацииResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ВыгрузкаСправочнойИнформацииResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ВыгрузкаСправочнойИнформацииResponse *p;
	size_t k = sizeof(_ns1__ВыгрузкаСправочнойИнформацииResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформацииResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ВыгрузкаСправочнойИнформацииResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ВыгрузкаСправочнойИнформацииResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ВыгрузкаСправочнойИнформацииResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ВыгрузкаСправочнойИнформацииResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ВыгрузкаСправочнойИнформацииResponse(soap, tag ? tag : "ns1:ВыгрузкаСправочнойИнформацииResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ВыгрузкаСправочнойИнформацииResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ВыгрузкаСправочнойИнформацииResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ВыгрузкаСправочнойИнформацииResponse * SOAP_FMAC4 soap_get__ns1__ВыгрузкаСправочнойИнформацииResponse(struct soap *soap, _ns1__ВыгрузкаСправочнойИнформацииResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ВыгрузкаСправочнойИнформацииResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ВыгрузкаСправочнойИнформации::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ВыгрузкаСправочнойИнформации::_ТекстЗапроса = NULL;
	this->_ns1__ВыгрузкаСправочнойИнформации::_СтатусСостояния = NULL;
	this->_ns1__ВыгрузкаСправочнойИнформации::_ОжидатьЗавершения = NULL;
	this->_ns1__ВыгрузкаСправочнойИнформации::_ВыгСправочник = NULL;
}

void _ns1__ВыгрузкаСправочнойИнформации::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ValueStorage(soap, &this->_ns1__ВыгрузкаСправочнойИнформации::_ТекстЗапроса);
	soap_serialize_PointerTons1__ValueStorage(soap, &this->_ns1__ВыгрузкаСправочнойИнформации::_СтатусСостояния);
	soap_serialize_PointerToxsd__decimal(soap, &this->_ns1__ВыгрузкаСправочнойИнформации::_ОжидатьЗавершения);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ВыгрузкаСправочнойИнформации::_ВыгСправочник);
#endif
}

int _ns1__ВыгрузкаСправочнойИнформации::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ВыгрузкаСправочнойИнформации(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, const char *tag, int id, const _ns1__ВыгрузкаСправочнойИнформации *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации), type))
		return soap->error;
	if (!a->_ns1__ВыгрузкаСправочнойИнформации::_ТекстЗапроса)
	{	if (soap_element_nil(soap, "ns1:ТекстЗапроса"))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ValueStorage(soap, "ns1:ТекстЗапроса", -1, &a->_ns1__ВыгрузкаСправочнойИнформации::_ТекстЗапроса, ""))
		return soap->error;
	if (!a->_ns1__ВыгрузкаСправочнойИнформации::_СтатусСостояния)
	{	if (soap_element_nil(soap, "ns1:СтатусСостояния"))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ValueStorage(soap, "ns1:СтатусСостояния", -1, &a->_ns1__ВыгрузкаСправочнойИнформации::_СтатусСостояния, ""))
		return soap->error;
	if (!a->_ns1__ВыгрузкаСправочнойИнформации::_ОжидатьЗавершения)
	{	if (soap_element_nil(soap, "ns1:ОжидатьЗавершения"))
			return soap->error;
	}
	else if (soap_out_PointerToxsd__decimal(soap, "ns1:ОжидатьЗавершения", -1, &a->_ns1__ВыгрузкаСправочнойИнформации::_ОжидатьЗавершения, ""))
		return soap->error;
	if (!a->_ns1__ВыгрузкаСправочнойИнформации::_ВыгСправочник)
	{	if (soap_element_nil(soap, "ns1:ВыгСправочник"))
			return soap->error;
	}
	else if (soap_out_PointerTostd__string(soap, "ns1:ВыгСправочник", -1, &a->_ns1__ВыгрузкаСправочнойИнформации::_ВыгСправочник, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ВыгрузкаСправочнойИнформации::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__ВыгрузкаСправочнойИнформации(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ВыгрузкаСправочнойИнформации * SOAP_FMAC4 soap_in__ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, const char *tag, _ns1__ВыгрузкаСправочнойИнформации *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ВыгрузкаСправочнойИнформации*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации, sizeof(_ns1__ВыгрузкаСправочнойИнформации), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ВыгрузкаСправочнойИнформации *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag__ТекстЗапроса1 = 1;
	size_t soap_flag__СтатусСостояния1 = 1;
	size_t soap_flag__ОжидатьЗавершения1 = 1;
	size_t soap_flag__ВыгСправочник1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__ТекстЗапроса1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ValueStorage(soap, NULL, &a->_ns1__ВыгрузкаСправочнойИнформации::_ТекстЗапроса, "ns1:ValueStorage"))
				{	soap_flag__ТекстЗапроса1--;
					continue;
				}
			}
			if (soap_flag__СтатусСостояния1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ValueStorage(soap, NULL, &a->_ns1__ВыгрузкаСправочнойИнформации::_СтатусСостояния, "ns1:ValueStorage"))
				{	soap_flag__СтатусСостояния1--;
					continue;
				}
			}
			if (soap_flag__ОжидатьЗавершения1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__decimal(soap, NULL, &a->_ns1__ВыгрузкаСправочнойИнформации::_ОжидатьЗавершения, "xsd:decimal"))
				{	soap_flag__ОжидатьЗавершения1--;
					continue;
				}
			}
			if (soap_flag__ВыгСправочник1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, NULL, &a->_ns1__ВыгрузкаСправочнойИнформации::_ВыгСправочник, "xsd:string"))
				{	soap_flag__ВыгСправочник1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__ТекстЗапроса1 > 0 || soap_flag__СтатусСостояния1 > 0 || soap_flag__ОжидатьЗавершения1 > 0 || soap_flag__ВыгСправочник1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ВыгрузкаСправочнойИнформации *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации, SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации, sizeof(_ns1__ВыгрузкаСправочнойИнформации), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ВыгрузкаСправочнойИнформации * SOAP_FMAC2 soap_instantiate__ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ВыгрузкаСправочнойИнформации(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ВыгрузкаСправочнойИнформации *p;
	size_t k = sizeof(_ns1__ВыгрузкаСправочнойИнформации);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ВыгрузкаСправочнойИнформации);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ВыгрузкаСправочнойИнформации, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ВыгрузкаСправочнойИнформации location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ВыгрузкаСправочнойИнформации::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ВыгрузкаСправочнойИнформации(soap, tag ? tag : "ns1:ВыгрузкаСправочнойИнформации", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ВыгрузкаСправочнойИнформации::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ВыгрузкаСправочнойИнформации(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ВыгрузкаСправочнойИнформации * SOAP_FMAC4 soap_get__ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, _ns1__ВыгрузкаСправочнойИнформации *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ВыгрузкаСправочнойИнформации(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ПринятьПакетОбменаResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ПринятьПакетОбменаResponse::return_ = NULL;
}

void _ns1__ПринятьПакетОбменаResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ValueStorage(soap, &this->_ns1__ПринятьПакетОбменаResponse::return_);
#endif
}

int _ns1__ПринятьПакетОбменаResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ПринятьПакетОбменаResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ПринятьПакетОбменаResponse(struct soap *soap, const char *tag, int id, const _ns1__ПринятьПакетОбменаResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ПринятьПакетОбменаResponse), type))
		return soap->error;
	if (a->return_)
		soap_element_result(soap, "ns1:return");
	if (!a->_ns1__ПринятьПакетОбменаResponse::return_)
	{	if (soap_element_nil(soap, "ns1:return"))
			return soap->error;
	}
	else if (soap_out_PointerTons1__ValueStorage(soap, "ns1:return", -1, &a->_ns1__ПринятьПакетОбменаResponse::return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ПринятьПакетОбменаResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__ПринятьПакетОбменаResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ПринятьПакетОбменаResponse * SOAP_FMAC4 soap_in__ns1__ПринятьПакетОбменаResponse(struct soap *soap, const char *tag, _ns1__ПринятьПакетОбменаResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ПринятьПакетОбменаResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ПринятьПакетОбменаResponse, sizeof(_ns1__ПринятьПакетОбменаResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ПринятьПакетОбменаResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ПринятьПакетОбменаResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_return_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ValueStorage(soap, "ns1:return", &a->_ns1__ПринятьПакетОбменаResponse::return_, "ns1:ValueStorage"))
				{	soap_flag_return_1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:return");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ПринятьПакетОбменаResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ПринятьПакетОбменаResponse, SOAP_TYPE__ns1__ПринятьПакетОбменаResponse, sizeof(_ns1__ПринятьПакетОбменаResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ПринятьПакетОбменаResponse * SOAP_FMAC2 soap_instantiate__ns1__ПринятьПакетОбменаResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ПринятьПакетОбменаResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ПринятьПакетОбменаResponse *p;
	size_t k = sizeof(_ns1__ПринятьПакетОбменаResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ПринятьПакетОбменаResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ПринятьПакетОбменаResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ПринятьПакетОбменаResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ПринятьПакетОбменаResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ПринятьПакетОбменаResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ПринятьПакетОбменаResponse(soap, tag ? tag : "ns1:ПринятьПакетОбменаResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ПринятьПакетОбменаResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ПринятьПакетОбменаResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ПринятьПакетОбменаResponse * SOAP_FMAC4 soap_get__ns1__ПринятьПакетОбменаResponse(struct soap *soap, _ns1__ПринятьПакетОбменаResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ПринятьПакетОбменаResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ПринятьПакетОбмена::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__ValueStorage(soap, &this->_ns1__ПринятьПакетОбмена::_ДанныеМобильногоПриложения);
}

void _ns1__ПринятьПакетОбмена::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__ПринятьПакетОбмена::_ДанныеМобильногоПриложения, SOAP_TYPE_ns1__ValueStorage);
	soap_serialize_ns1__ValueStorage(soap, &this->_ns1__ПринятьПакетОбмена::_ДанныеМобильногоПриложения);
#endif
}

int _ns1__ПринятьПакетОбмена::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ПринятьПакетОбмена(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ПринятьПакетОбмена(struct soap *soap, const char *tag, int id, const _ns1__ПринятьПакетОбмена *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ПринятьПакетОбмена), type))
		return soap->error;
	if (soap_out_ns1__ValueStorage(soap, "ns1:ДанныеМобильногоПриложения", -1, &a->_ns1__ПринятьПакетОбмена::_ДанныеМобильногоПриложения, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ПринятьПакетОбмена::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__ns1__ПринятьПакетОбмена(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ПринятьПакетОбмена * SOAP_FMAC4 soap_in__ns1__ПринятьПакетОбмена(struct soap *soap, const char *tag, _ns1__ПринятьПакетОбмена *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ПринятьПакетОбмена*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ПринятьПакетОбмена, sizeof(_ns1__ПринятьПакетОбмена), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ПринятьПакетОбмена)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ПринятьПакетОбмена *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag__ДанныеМобильногоПриложения1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__ДанныеМобильногоПриложения1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__ValueStorage(soap, NULL, &a->_ns1__ПринятьПакетОбмена::_ДанныеМобильногоПриложения, "ns1:ValueStorage"))
				{	soap_flag__ДанныеМобильногоПриложения1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__ДанныеМобильногоПриложения1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ПринятьПакетОбмена *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ПринятьПакетОбмена, SOAP_TYPE__ns1__ПринятьПакетОбмена, sizeof(_ns1__ПринятьПакетОбмена), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ПринятьПакетОбмена * SOAP_FMAC2 soap_instantiate__ns1__ПринятьПакетОбмена(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ПринятьПакетОбмена(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ПринятьПакетОбмена *p;
	size_t k = sizeof(_ns1__ПринятьПакетОбмена);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ПринятьПакетОбмена, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ПринятьПакетОбмена);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ПринятьПакетОбмена, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ПринятьПакетОбмена location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ПринятьПакетОбмена::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ПринятьПакетОбмена(soap, tag ? tag : "ns1:ПринятьПакетОбмена", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ПринятьПакетОбмена::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ПринятьПакетОбмена(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ПринятьПакетОбмена * SOAP_FMAC4 soap_get__ns1__ПринятьПакетОбмена(struct soap *soap, _ns1__ПринятьПакетОбмена *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ПринятьПакетОбмена(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ValueTreeRow::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ValueTreeRow(soap, &this->ns1__ValueTreeRow::row);
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns1__ValueTreeRow::Value);
}

void ns1__ValueTreeRow::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__ValueTreeRow(soap, &this->ns1__ValueTreeRow::row);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns1__ValueTreeRow::Value);
#endif
}

int ns1__ValueTreeRow::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ValueTreeRow(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ValueTreeRow(struct soap *soap, const char *tag, int id, const ns1__ValueTreeRow *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ValueTreeRow), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ValueTreeRow(soap, "ns1:row", -1, &a->ns1__ValueTreeRow::row, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "ns1:Value", -1, &a->ns1__ValueTreeRow::Value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ValueTreeRow::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ValueTreeRow(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ValueTreeRow * SOAP_FMAC4 soap_in_ns1__ValueTreeRow(struct soap *soap, const char *tag, ns1__ValueTreeRow *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ValueTreeRow*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ValueTreeRow, sizeof(ns1__ValueTreeRow), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ValueTreeRow)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ValueTreeRow *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__ValueTreeRow(soap, "ns1:row", &a->ns1__ValueTreeRow::row, "ns1:ValueTreeRow"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "ns1:Value", &a->ns1__ValueTreeRow::Value, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ValueTreeRow *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ValueTreeRow, SOAP_TYPE_ns1__ValueTreeRow, sizeof(ns1__ValueTreeRow), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ValueTreeRow * SOAP_FMAC2 soap_instantiate_ns1__ValueTreeRow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ValueTreeRow(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ValueTreeRow *p;
	size_t k = sizeof(ns1__ValueTreeRow);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ValueTreeRow, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ValueTreeRow);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ValueTreeRow, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ValueTreeRow location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ValueTreeRow::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ValueTreeRow(soap, tag ? tag : "ns1:ValueTreeRow", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ValueTreeRow::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ValueTreeRow(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ValueTreeRow * SOAP_FMAC4 soap_get_ns1__ValueTreeRow(struct soap *soap, ns1__ValueTreeRow *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ValueTreeRow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ValueTreeColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ValueTreeColumn::Name = NULL;
	this->ns1__ValueTreeColumn::ValueType = NULL;
	this->ns1__ValueTreeColumn::Title = NULL;
	this->ns1__ValueTreeColumn::Width = NULL;
}

void ns1__ValueTreeColumn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__NMTOKEN(soap, &this->ns1__ValueTreeColumn::Name);
	soap_serialize_PointerTons1__TypeDescription(soap, &this->ns1__ValueTreeColumn::ValueType);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ValueTreeColumn::Title);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->ns1__ValueTreeColumn::Width);
#endif
}

int ns1__ValueTreeColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ValueTreeColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ValueTreeColumn(struct soap *soap, const char *tag, int id, const ns1__ValueTreeColumn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ValueTreeColumn), type))
		return soap->error;
	if (soap_out_PointerToxsd__NMTOKEN(soap, "ns1:Name", -1, &a->ns1__ValueTreeColumn::Name, ""))
		return soap->error;
	if (soap_out_PointerTons1__TypeDescription(soap, "ns1:ValueType", -1, &a->ns1__ValueTreeColumn::ValueType, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Title", -1, &a->ns1__ValueTreeColumn::Title, ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "ns1:Width", -1, &a->ns1__ValueTreeColumn::Width, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ValueTreeColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ValueTreeColumn(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ValueTreeColumn * SOAP_FMAC4 soap_in_ns1__ValueTreeColumn(struct soap *soap, const char *tag, ns1__ValueTreeColumn *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ValueTreeColumn*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ValueTreeColumn, sizeof(ns1__ValueTreeColumn), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ValueTreeColumn)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ValueTreeColumn *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_ValueType1 = 1;
	size_t soap_flag_Title1 = 1;
	size_t soap_flag_Width1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__NMTOKEN(soap, "ns1:Name", &a->ns1__ValueTreeColumn::Name, "xsd:NMTOKEN"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_ValueType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TypeDescription(soap, "ns1:ValueType", &a->ns1__ValueTreeColumn::ValueType, "ns1:TypeDescription"))
				{	soap_flag_ValueType1--;
					continue;
				}
			}
			if (soap_flag_Title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Title", &a->ns1__ValueTreeColumn::Title, "xsd:string"))
				{	soap_flag_Title1--;
					continue;
				}
			}
			if (soap_flag_Width1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__nonNegativeInteger(soap, "ns1:Width", &a->ns1__ValueTreeColumn::Width, "xsd:nonNegativeInteger"))
				{	soap_flag_Width1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ValueTreeColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ValueTreeColumn, SOAP_TYPE_ns1__ValueTreeColumn, sizeof(ns1__ValueTreeColumn), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ValueTreeColumn * SOAP_FMAC2 soap_instantiate_ns1__ValueTreeColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ValueTreeColumn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ValueTreeColumn *p;
	size_t k = sizeof(ns1__ValueTreeColumn);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ValueTreeColumn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ValueTreeColumn);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ValueTreeColumn, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ValueTreeColumn location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ValueTreeColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ValueTreeColumn(soap, tag ? tag : "ns1:ValueTreeColumn", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ValueTreeColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ValueTreeColumn(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ValueTreeColumn * SOAP_FMAC4 soap_get_ns1__ValueTreeColumn(struct soap *soap, ns1__ValueTreeColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ValueTreeColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ValueTree::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ValueTreeColumn(soap, &this->ns1__ValueTree::column);
	soap_default_std__vectorTemplateOfPointerTons1__ValueTreeRow(soap, &this->ns1__ValueTree::row);
}

void ns1__ValueTree::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__ValueTreeColumn(soap, &this->ns1__ValueTree::column);
	soap_serialize_std__vectorTemplateOfPointerTons1__ValueTreeRow(soap, &this->ns1__ValueTree::row);
#endif
}

int ns1__ValueTree::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ValueTree(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ValueTree(struct soap *soap, const char *tag, int id, const ns1__ValueTree *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ValueTree), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ValueTreeColumn(soap, "ns1:column", -1, &a->ns1__ValueTree::column, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ValueTreeRow(soap, "ns1:row", -1, &a->ns1__ValueTree::row, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ValueTree::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ValueTree(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ValueTree * SOAP_FMAC4 soap_in_ns1__ValueTree(struct soap *soap, const char *tag, ns1__ValueTree *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ValueTree*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ValueTree, sizeof(ns1__ValueTree), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ValueTree)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ValueTree *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__ValueTreeColumn(soap, "ns1:column", &a->ns1__ValueTree::column, "ns1:ValueTreeColumn"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__ValueTreeRow(soap, "ns1:row", &a->ns1__ValueTree::row, "ns1:ValueTreeRow"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ValueTree *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ValueTree, SOAP_TYPE_ns1__ValueTree, sizeof(ns1__ValueTree), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ValueTree * SOAP_FMAC2 soap_instantiate_ns1__ValueTree(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ValueTree(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ValueTree *p;
	size_t k = sizeof(ns1__ValueTree);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ValueTree, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ValueTree);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ValueTree, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ValueTree location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ValueTree::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ValueTree(soap, tag ? tag : "ns1:ValueTree", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ValueTree::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ValueTree(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ValueTree * SOAP_FMAC4 soap_get_ns1__ValueTree(struct soap *soap, ns1__ValueTree *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ValueTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ValueTableRow::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns1__ValueTableRow::Value);
}

void ns1__ValueTableRow::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns1__ValueTableRow::Value);
#endif
}

int ns1__ValueTableRow::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ValueTableRow(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ValueTableRow(struct soap *soap, const char *tag, int id, const ns1__ValueTableRow *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ValueTableRow), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "ns1:Value", -1, &a->ns1__ValueTableRow::Value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ValueTableRow::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ValueTableRow(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ValueTableRow * SOAP_FMAC4 soap_in_ns1__ValueTableRow(struct soap *soap, const char *tag, ns1__ValueTableRow *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ValueTableRow*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ValueTableRow, sizeof(ns1__ValueTableRow), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ValueTableRow)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ValueTableRow *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "ns1:Value", &a->ns1__ValueTableRow::Value, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ValueTableRow *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ValueTableRow, SOAP_TYPE_ns1__ValueTableRow, sizeof(ns1__ValueTableRow), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ValueTableRow * SOAP_FMAC2 soap_instantiate_ns1__ValueTableRow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ValueTableRow(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ValueTableRow *p;
	size_t k = sizeof(ns1__ValueTableRow);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ValueTableRow, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ValueTableRow);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ValueTableRow, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ValueTableRow location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ValueTableRow::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ValueTableRow(soap, tag ? tag : "ns1:ValueTableRow", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ValueTableRow::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ValueTableRow(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ValueTableRow * SOAP_FMAC4 soap_get_ns1__ValueTableRow(struct soap *soap, ns1__ValueTableRow *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ValueTableRow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ValueTableIndex::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__NMTOKEN(soap, &this->ns1__ValueTableIndex::column);
}

void ns1__ValueTableIndex::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__NMTOKEN(soap, &this->ns1__ValueTableIndex::column);
#endif
}

int ns1__ValueTableIndex::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ValueTableIndex(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ValueTableIndex(struct soap *soap, const char *tag, int id, const ns1__ValueTableIndex *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ValueTableIndex), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__NMTOKEN(soap, "ns1:column", -1, &a->ns1__ValueTableIndex::column, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ValueTableIndex::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ValueTableIndex(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ValueTableIndex * SOAP_FMAC4 soap_in_ns1__ValueTableIndex(struct soap *soap, const char *tag, ns1__ValueTableIndex *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ValueTableIndex*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ValueTableIndex, sizeof(ns1__ValueTableIndex), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ValueTableIndex)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ValueTableIndex *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__NMTOKEN(soap, "ns1:column", &a->ns1__ValueTableIndex::column, "xsd:NMTOKEN"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__ValueTableIndex::column.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ValueTableIndex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ValueTableIndex, SOAP_TYPE_ns1__ValueTableIndex, sizeof(ns1__ValueTableIndex), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ValueTableIndex * SOAP_FMAC2 soap_instantiate_ns1__ValueTableIndex(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ValueTableIndex(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ValueTableIndex *p;
	size_t k = sizeof(ns1__ValueTableIndex);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ValueTableIndex, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ValueTableIndex);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ValueTableIndex, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ValueTableIndex location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ValueTableIndex::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ValueTableIndex(soap, tag ? tag : "ns1:ValueTableIndex", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ValueTableIndex::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ValueTableIndex(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ValueTableIndex * SOAP_FMAC4 soap_get_ns1__ValueTableIndex(struct soap *soap, ns1__ValueTableIndex *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ValueTableIndex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ValueTableColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ValueTableColumn::Name = NULL;
	this->ns1__ValueTableColumn::ValueType = NULL;
	this->ns1__ValueTableColumn::Title = NULL;
	this->ns1__ValueTableColumn::Width = NULL;
}

void ns1__ValueTableColumn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__NMTOKEN(soap, &this->ns1__ValueTableColumn::Name);
	soap_serialize_PointerTons1__TypeDescription(soap, &this->ns1__ValueTableColumn::ValueType);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ValueTableColumn::Title);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->ns1__ValueTableColumn::Width);
#endif
}

int ns1__ValueTableColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ValueTableColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ValueTableColumn(struct soap *soap, const char *tag, int id, const ns1__ValueTableColumn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ValueTableColumn), type))
		return soap->error;
	if (soap_out_PointerToxsd__NMTOKEN(soap, "ns1:Name", -1, &a->ns1__ValueTableColumn::Name, ""))
		return soap->error;
	if (soap_out_PointerTons1__TypeDescription(soap, "ns1:ValueType", -1, &a->ns1__ValueTableColumn::ValueType, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Title", -1, &a->ns1__ValueTableColumn::Title, ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "ns1:Width", -1, &a->ns1__ValueTableColumn::Width, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ValueTableColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ValueTableColumn(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ValueTableColumn * SOAP_FMAC4 soap_in_ns1__ValueTableColumn(struct soap *soap, const char *tag, ns1__ValueTableColumn *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ValueTableColumn*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ValueTableColumn, sizeof(ns1__ValueTableColumn), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ValueTableColumn)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ValueTableColumn *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_ValueType1 = 1;
	size_t soap_flag_Title1 = 1;
	size_t soap_flag_Width1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__NMTOKEN(soap, "ns1:Name", &a->ns1__ValueTableColumn::Name, "xsd:NMTOKEN"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_ValueType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TypeDescription(soap, "ns1:ValueType", &a->ns1__ValueTableColumn::ValueType, "ns1:TypeDescription"))
				{	soap_flag_ValueType1--;
					continue;
				}
			}
			if (soap_flag_Title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Title", &a->ns1__ValueTableColumn::Title, "xsd:string"))
				{	soap_flag_Title1--;
					continue;
				}
			}
			if (soap_flag_Width1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__nonNegativeInteger(soap, "ns1:Width", &a->ns1__ValueTableColumn::Width, "xsd:nonNegativeInteger"))
				{	soap_flag_Width1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ValueTableColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ValueTableColumn, SOAP_TYPE_ns1__ValueTableColumn, sizeof(ns1__ValueTableColumn), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ValueTableColumn * SOAP_FMAC2 soap_instantiate_ns1__ValueTableColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ValueTableColumn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ValueTableColumn *p;
	size_t k = sizeof(ns1__ValueTableColumn);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ValueTableColumn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ValueTableColumn);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ValueTableColumn, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ValueTableColumn location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ValueTableColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ValueTableColumn(soap, tag ? tag : "ns1:ValueTableColumn", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ValueTableColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ValueTableColumn(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ValueTableColumn * SOAP_FMAC4 soap_get_ns1__ValueTableColumn(struct soap *soap, ns1__ValueTableColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ValueTableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ValueTable::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ValueTableColumn(soap, &this->ns1__ValueTable::column);
	soap_default_std__vectorTemplateOfPointerTons1__ValueTableIndex(soap, &this->ns1__ValueTable::index);
	soap_default_std__vectorTemplateOfPointerTons1__ValueTableRow(soap, &this->ns1__ValueTable::row);
}

void ns1__ValueTable::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__ValueTableColumn(soap, &this->ns1__ValueTable::column);
	soap_serialize_std__vectorTemplateOfPointerTons1__ValueTableIndex(soap, &this->ns1__ValueTable::index);
	soap_serialize_std__vectorTemplateOfPointerTons1__ValueTableRow(soap, &this->ns1__ValueTable::row);
#endif
}

int ns1__ValueTable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ValueTable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ValueTable(struct soap *soap, const char *tag, int id, const ns1__ValueTable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ValueTable), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ValueTableColumn(soap, "ns1:column", -1, &a->ns1__ValueTable::column, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ValueTableIndex(soap, "ns1:index", -1, &a->ns1__ValueTable::index, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ValueTableRow(soap, "ns1:row", -1, &a->ns1__ValueTable::row, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ValueTable::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ValueTable(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ValueTable * SOAP_FMAC4 soap_in_ns1__ValueTable(struct soap *soap, const char *tag, ns1__ValueTable *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ValueTable*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ValueTable, sizeof(ns1__ValueTable), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ValueTable)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ValueTable *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__ValueTableColumn(soap, "ns1:column", &a->ns1__ValueTable::column, "ns1:ValueTableColumn"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__ValueTableIndex(soap, "ns1:index", &a->ns1__ValueTable::index, "ns1:ValueTableIndex"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__ValueTableRow(soap, "ns1:row", &a->ns1__ValueTable::row, "ns1:ValueTableRow"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ValueTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ValueTable, SOAP_TYPE_ns1__ValueTable, sizeof(ns1__ValueTable), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ValueTable * SOAP_FMAC2 soap_instantiate_ns1__ValueTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ValueTable(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ValueTable *p;
	size_t k = sizeof(ns1__ValueTable);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ValueTable, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ValueTable);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ValueTable, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ValueTable location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ValueTable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ValueTable(soap, tag ? tag : "ns1:ValueTable", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ValueTable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ValueTable(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ValueTable * SOAP_FMAC4 soap_get_ns1__ValueTable(struct soap *soap, ns1__ValueTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ValueTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ValueListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ValueListType::__union_ValueListType = 0;
}

void ns1__ValueListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_ValueListType(soap, this->ns1__ValueListType::__union_ValueListType, &this->ns1__ValueListType::union_ValueListType);
#endif
}

int ns1__ValueListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ValueListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ValueListType(struct soap *soap, const char *tag, int id, const ns1__ValueListType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ValueListType), type))
		return soap->error;
	if (soap_out__ns1__union_ValueListType(soap, a->ns1__ValueListType::__union_ValueListType, &a->ns1__ValueListType::union_ValueListType))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ValueListType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ValueListType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ValueListType * SOAP_FMAC4 soap_in_ns1__ValueListType(struct soap *soap, const char *tag, ns1__ValueListType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ValueListType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ValueListType, sizeof(ns1__ValueListType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns1__union_ValueListType(soap, &a->__union_ValueListType, &a->union_ValueListType))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns1__ValueListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ValueListType, SOAP_TYPE_ns1__ValueListType, sizeof(ns1__ValueListType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ValueListType * SOAP_FMAC2 soap_instantiate_ns1__ValueListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ValueListType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ValueListType *p;
	size_t k = sizeof(ns1__ValueListType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ValueListType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ValueListType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ValueListType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ValueListType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ValueListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ValueListType(soap, tag ? tag : "ns1:ValueListType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ValueListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ValueListType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ValueListType * SOAP_FMAC4 soap_get_ns1__ValueListType(struct soap *soap, ns1__ValueListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ValueListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ValueListItemType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ValueListItemType::value = NULL;
	this->ns1__ValueListItemType::presentation = NULL;
	this->ns1__ValueListItemType::checkState = NULL;
	this->ns1__ValueListItemType::picture = NULL;
	this->ns1__ValueListItemType::id = NULL;
	this->ns1__ValueListItemType::formatPresentationSpecified = NULL;
	this->ns1__ValueListItemType::formatPresentation = NULL;
}

void ns1__ValueListItemType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__ValueListItemType::presentation);
	soap_serialize_PointerToxsd__decimal(soap, &this->ns1__ValueListItemType::checkState);
	soap_serialize_PointerToLONG64(soap, &this->ns1__ValueListItemType::id);
	soap_serialize_PointerTobool(soap, &this->ns1__ValueListItemType::formatPresentationSpecified);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ValueListItemType::formatPresentation);
#endif
}

int ns1__ValueListItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ValueListItemType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ValueListItemType(struct soap *soap, const char *tag, int id, const ns1__ValueListItemType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ValueListItemType), type))
		return soap->error;
	if (!a->ns1__ValueListItemType::value)
	{	if (soap_element_nil(soap, "ns1:value"))
			return soap->error;
	}
	else if (soap_outliteral(soap, "ns1:value", (char*const*)&a->ns1__ValueListItemType::value, NULL))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:presentation", -1, &a->ns1__ValueListItemType::presentation, ""))
		return soap->error;
	if (soap_out_PointerToxsd__decimal(soap, "ns1:checkState", -1, &a->ns1__ValueListItemType::checkState, ""))
		return soap->error;
	if (soap_outliteral(soap, "ns1:picture", (char*const*)&a->ns1__ValueListItemType::picture, NULL))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "ns1:id", -1, &a->ns1__ValueListItemType::id, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:formatPresentationSpecified", -1, &a->ns1__ValueListItemType::formatPresentationSpecified, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:formatPresentation", -1, &a->ns1__ValueListItemType::formatPresentation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ValueListItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ValueListItemType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ValueListItemType * SOAP_FMAC4 soap_in_ns1__ValueListItemType(struct soap *soap, const char *tag, ns1__ValueListItemType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ValueListItemType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ValueListItemType, sizeof(ns1__ValueListItemType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ValueListItemType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ValueListItemType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_value1 = 1;
	size_t soap_flag_presentation1 = 1;
	size_t soap_flag_checkState1 = 1;
	size_t soap_flag_picture1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_formatPresentationSpecified1 = 1;
	size_t soap_flag_formatPresentation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns1:value", (char**)&a->ns1__ValueListItemType::value))
				{	soap_flag_value1--;
					continue;
				}
			}
			if (soap_flag_presentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:presentation", &a->ns1__ValueListItemType::presentation, "xsd:string"))
				{	soap_flag_presentation1--;
					continue;
				}
			}
			if (soap_flag_checkState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__decimal(soap, "ns1:checkState", &a->ns1__ValueListItemType::checkState, "xsd:decimal"))
				{	soap_flag_checkState1--;
					continue;
				}
			}
			if (soap_flag_picture1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns1:picture", (char**)&a->ns1__ValueListItemType::picture))
				{	soap_flag_picture1--;
					continue;
				}
			}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToLONG64(soap, "ns1:id", &a->ns1__ValueListItemType::id, "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			}
			if (soap_flag_formatPresentationSpecified1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "ns1:formatPresentationSpecified", &a->ns1__ValueListItemType::formatPresentationSpecified, "xsd:boolean"))
				{	soap_flag_formatPresentationSpecified1--;
					continue;
				}
			}
			if (soap_flag_formatPresentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:formatPresentation", &a->ns1__ValueListItemType::formatPresentation, "xsd:string"))
				{	soap_flag_formatPresentation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ValueListItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ValueListItemType, SOAP_TYPE_ns1__ValueListItemType, sizeof(ns1__ValueListItemType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ValueListItemType * SOAP_FMAC2 soap_instantiate_ns1__ValueListItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ValueListItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ValueListItemType *p;
	size_t k = sizeof(ns1__ValueListItemType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ValueListItemType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ValueListItemType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ValueListItemType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ValueListItemType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ValueListItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ValueListItemType(soap, tag ? tag : "ns1:ValueListItemType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ValueListItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ValueListItemType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ValueListItemType * SOAP_FMAC4 soap_get_ns1__ValueListItemType(struct soap *soap, ns1__ValueListItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ValueListItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TypeDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->ns1__TypeDescription::Type);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->ns1__TypeDescription::TypeSet);
	soap_default_std__vectorTemplateOfns1__UUID(soap, &this->ns1__TypeDescription::TypeId);
	this->ns1__TypeDescription::NumberQualifiers = NULL;
	this->ns1__TypeDescription::StringQualifiers = NULL;
	this->ns1__TypeDescription::DateQualifiers = NULL;
	this->ns1__TypeDescription::BinaryDataQualifiers = NULL;
}

void ns1__TypeDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->ns1__TypeDescription::Type);
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->ns1__TypeDescription::TypeSet);
	soap_serialize_std__vectorTemplateOfns1__UUID(soap, &this->ns1__TypeDescription::TypeId);
	soap_serialize_PointerTons1__NumberQualifiers(soap, &this->ns1__TypeDescription::NumberQualifiers);
	soap_serialize_PointerTons1__StringQualifiers(soap, &this->ns1__TypeDescription::StringQualifiers);
	soap_serialize_PointerTons1__DateQualifiers(soap, &this->ns1__TypeDescription::DateQualifiers);
	soap_serialize_PointerTons1__BinaryDataQualifiers(soap, &this->ns1__TypeDescription::BinaryDataQualifiers);
#endif
}

int ns1__TypeDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TypeDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TypeDescription(struct soap *soap, const char *tag, int id, const ns1__TypeDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TypeDescription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "ns1:Type", -1, &a->ns1__TypeDescription::Type, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "ns1:TypeSet", -1, &a->ns1__TypeDescription::TypeSet, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__UUID(soap, "ns1:TypeId", -1, &a->ns1__TypeDescription::TypeId, ""))
		return soap->error;
	if (soap_out_PointerTons1__NumberQualifiers(soap, "ns1:NumberQualifiers", -1, &a->ns1__TypeDescription::NumberQualifiers, ""))
		return soap->error;
	if (soap_out_PointerTons1__StringQualifiers(soap, "ns1:StringQualifiers", -1, &a->ns1__TypeDescription::StringQualifiers, ""))
		return soap->error;
	if (soap_out_PointerTons1__DateQualifiers(soap, "ns1:DateQualifiers", -1, &a->ns1__TypeDescription::DateQualifiers, ""))
		return soap->error;
	if (soap_out_PointerTons1__BinaryDataQualifiers(soap, "ns1:BinaryDataQualifiers", -1, &a->ns1__TypeDescription::BinaryDataQualifiers, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TypeDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TypeDescription(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TypeDescription * SOAP_FMAC4 soap_in_ns1__TypeDescription(struct soap *soap, const char *tag, ns1__TypeDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TypeDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TypeDescription, sizeof(ns1__TypeDescription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TypeDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TypeDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NumberQualifiers1 = 1;
	size_t soap_flag_StringQualifiers1 = 1;
	size_t soap_flag_DateQualifiers1 = 1;
	size_t soap_flag_BinaryDataQualifiers1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__QName(soap, "ns1:Type", &a->ns1__TypeDescription::Type, "xsd:QName"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__QName(soap, "ns1:TypeSet", &a->ns1__TypeDescription::TypeSet, "xsd:QName"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns1__UUID(soap, "ns1:TypeId", &a->ns1__TypeDescription::TypeId, "ns1:UUID"))
					continue;
			}
			if (soap_flag_NumberQualifiers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__NumberQualifiers(soap, "ns1:NumberQualifiers", &a->ns1__TypeDescription::NumberQualifiers, "ns1:NumberQualifiers"))
				{	soap_flag_NumberQualifiers1--;
					continue;
				}
			}
			if (soap_flag_StringQualifiers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__StringQualifiers(soap, "ns1:StringQualifiers", &a->ns1__TypeDescription::StringQualifiers, "ns1:StringQualifiers"))
				{	soap_flag_StringQualifiers1--;
					continue;
				}
			}
			if (soap_flag_DateQualifiers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DateQualifiers(soap, "ns1:DateQualifiers", &a->ns1__TypeDescription::DateQualifiers, "ns1:DateQualifiers"))
				{	soap_flag_DateQualifiers1--;
					continue;
				}
			}
			if (soap_flag_BinaryDataQualifiers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__BinaryDataQualifiers(soap, "ns1:BinaryDataQualifiers", &a->ns1__TypeDescription::BinaryDataQualifiers, "ns1:BinaryDataQualifiers"))
				{	soap_flag_BinaryDataQualifiers1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TypeDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TypeDescription, SOAP_TYPE_ns1__TypeDescription, sizeof(ns1__TypeDescription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TypeDescription * SOAP_FMAC2 soap_instantiate_ns1__TypeDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TypeDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TypeDescription *p;
	size_t k = sizeof(ns1__TypeDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TypeDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TypeDescription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TypeDescription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TypeDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TypeDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TypeDescription(soap, tag ? tag : "ns1:TypeDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TypeDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TypeDescription(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TypeDescription * SOAP_FMAC4 soap_get_ns1__TypeDescription(struct soap *soap, ns1__TypeDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TypeDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Structure::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_ns1__Structure_Property(soap, &this->ns1__Structure::Property);
}

void ns1__Structure::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_ns1__Structure_Property(soap, &this->ns1__Structure::Property);
#endif
}

int ns1__Structure::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Structure(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Structure(struct soap *soap, const char *tag, int id, const ns1__Structure *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Structure), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns1__Structure_Property(soap, "ns1:Property", -1, &a->ns1__Structure::Property, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Structure::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Structure(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Structure * SOAP_FMAC4 soap_in_ns1__Structure(struct soap *soap, const char *tag, ns1__Structure *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Structure*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Structure, sizeof(ns1__Structure), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Structure)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Structure *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns1__Structure_Property(soap, "ns1:Property", &a->ns1__Structure::Property, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Structure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Structure, SOAP_TYPE_ns1__Structure, sizeof(ns1__Structure), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Structure * SOAP_FMAC2 soap_instantiate_ns1__Structure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Structure(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Structure *p;
	size_t k = sizeof(ns1__Structure);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Structure, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Structure);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Structure, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Structure location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Structure::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Structure(soap, tag ? tag : "ns1:Structure", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Structure::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Structure(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Structure * SOAP_FMAC4 soap_get_ns1__Structure(struct soap *soap, ns1__Structure *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Structure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__StringQualifiers::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__decimal(soap, &this->ns1__StringQualifiers::Length);
	soap_default_ns1__AllowedLength(soap, &this->ns1__StringQualifiers::AllowedLength);
}

void ns1__StringQualifiers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__StringQualifiers::Length, SOAP_TYPE_xsd__decimal);
	soap_serialize_xsd__decimal(soap, &this->ns1__StringQualifiers::Length);
#endif
}

int ns1__StringQualifiers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StringQualifiers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StringQualifiers(struct soap *soap, const char *tag, int id, const ns1__StringQualifiers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StringQualifiers), type))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns1:Length", -1, &a->ns1__StringQualifiers::Length, ""))
		return soap->error;
	if (soap_out_ns1__AllowedLength(soap, "ns1:AllowedLength", -1, &a->ns1__StringQualifiers::AllowedLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__StringQualifiers::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__StringQualifiers(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StringQualifiers * SOAP_FMAC4 soap_in_ns1__StringQualifiers(struct soap *soap, const char *tag, ns1__StringQualifiers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StringQualifiers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StringQualifiers, sizeof(ns1__StringQualifiers), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__StringQualifiers)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__StringQualifiers *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Length1 = 1;
	size_t soap_flag_AllowedLength1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Length1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "ns1:Length", &a->ns1__StringQualifiers::Length, "xsd:decimal"))
				{	soap_flag_Length1--;
					continue;
				}
			}
			if (soap_flag_AllowedLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__AllowedLength(soap, "ns1:AllowedLength", &a->ns1__StringQualifiers::AllowedLength, "ns1:AllowedLength"))
				{	soap_flag_AllowedLength1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Length1 > 0 || soap_flag_AllowedLength1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__StringQualifiers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StringQualifiers, SOAP_TYPE_ns1__StringQualifiers, sizeof(ns1__StringQualifiers), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__StringQualifiers * SOAP_FMAC2 soap_instantiate_ns1__StringQualifiers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StringQualifiers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__StringQualifiers *p;
	size_t k = sizeof(ns1__StringQualifiers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__StringQualifiers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__StringQualifiers);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__StringQualifiers, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__StringQualifiers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__StringQualifiers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__StringQualifiers(soap, tag ? tag : "ns1:StringQualifiers", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StringQualifiers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StringQualifiers(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StringQualifiers * SOAP_FMAC4 soap_get_ns1__StringQualifiers(struct soap *soap, ns1__StringQualifiers *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StringQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__StandardPeriod::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__StandardPeriod::variant = NULL;
	this->ns1__StandardPeriod::startDate = NULL;
	this->ns1__StandardPeriod::endDate = NULL;
}

void ns1__StandardPeriod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTodateTime(soap, &this->ns1__StandardPeriod::startDate);
	soap_serialize_PointerTodateTime(soap, &this->ns1__StandardPeriod::endDate);
#endif
}

int ns1__StandardPeriod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StandardPeriod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StandardPeriod(struct soap *soap, const char *tag, int id, const ns1__StandardPeriod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StandardPeriod), type))
		return soap->error;
	if (!a->ns1__StandardPeriod::variant)
	{	if (soap_element_empty(soap, "ns1:variant"))
			return soap->error;
	}
	else if (soap_outliteral(soap, "ns1:variant", (char*const*)&a->ns1__StandardPeriod::variant, NULL))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:startDate", -1, &a->ns1__StandardPeriod::startDate, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:endDate", -1, &a->ns1__StandardPeriod::endDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__StandardPeriod::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__StandardPeriod(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StandardPeriod * SOAP_FMAC4 soap_in_ns1__StandardPeriod(struct soap *soap, const char *tag, ns1__StandardPeriod *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StandardPeriod*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StandardPeriod, sizeof(ns1__StandardPeriod), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__StandardPeriod)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__StandardPeriod *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_variant1 = 1;
	size_t soap_flag_startDate1 = 1;
	size_t soap_flag_endDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_variant1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns1:variant", (char**)&a->ns1__StandardPeriod::variant))
				{	soap_flag_variant1--;
					continue;
				}
			}
			if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:startDate", &a->ns1__StandardPeriod::startDate, "xsd:dateTime"))
				{	soap_flag_startDate1--;
					continue;
				}
			}
			if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:endDate", &a->ns1__StandardPeriod::endDate, "xsd:dateTime"))
				{	soap_flag_endDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__StandardPeriod::variant))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__StandardPeriod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StandardPeriod, SOAP_TYPE_ns1__StandardPeriod, sizeof(ns1__StandardPeriod), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__StandardPeriod * SOAP_FMAC2 soap_instantiate_ns1__StandardPeriod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StandardPeriod(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__StandardPeriod *p;
	size_t k = sizeof(ns1__StandardPeriod);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__StandardPeriod, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__StandardPeriod);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__StandardPeriod, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__StandardPeriod location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__StandardPeriod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__StandardPeriod(soap, tag ? tag : "ns1:StandardPeriod", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StandardPeriod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StandardPeriod(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StandardPeriod * SOAP_FMAC4 soap_get_ns1__StandardPeriod(struct soap *soap, ns1__StandardPeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StandardPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__StandardBeginningDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__StandardBeginningDate::variant = NULL;
	this->ns1__StandardBeginningDate::date = NULL;
}

void ns1__StandardBeginningDate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTodateTime(soap, &this->ns1__StandardBeginningDate::date);
#endif
}

int ns1__StandardBeginningDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StandardBeginningDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StandardBeginningDate(struct soap *soap, const char *tag, int id, const ns1__StandardBeginningDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StandardBeginningDate), type))
		return soap->error;
	if (!a->ns1__StandardBeginningDate::variant)
	{	if (soap_element_empty(soap, "ns1:variant"))
			return soap->error;
	}
	else if (soap_outliteral(soap, "ns1:variant", (char*const*)&a->ns1__StandardBeginningDate::variant, NULL))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ns1:date", -1, &a->ns1__StandardBeginningDate::date, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__StandardBeginningDate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__StandardBeginningDate(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StandardBeginningDate * SOAP_FMAC4 soap_in_ns1__StandardBeginningDate(struct soap *soap, const char *tag, ns1__StandardBeginningDate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StandardBeginningDate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StandardBeginningDate, sizeof(ns1__StandardBeginningDate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__StandardBeginningDate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__StandardBeginningDate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_variant1 = 1;
	size_t soap_flag_date1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_variant1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns1:variant", (char**)&a->ns1__StandardBeginningDate::variant))
				{	soap_flag_variant1--;
					continue;
				}
			}
			if (soap_flag_date1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "ns1:date", &a->ns1__StandardBeginningDate::date, "xsd:dateTime"))
				{	soap_flag_date1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__StandardBeginningDate::variant))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__StandardBeginningDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StandardBeginningDate, SOAP_TYPE_ns1__StandardBeginningDate, sizeof(ns1__StandardBeginningDate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__StandardBeginningDate * SOAP_FMAC2 soap_instantiate_ns1__StandardBeginningDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StandardBeginningDate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__StandardBeginningDate *p;
	size_t k = sizeof(ns1__StandardBeginningDate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__StandardBeginningDate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__StandardBeginningDate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__StandardBeginningDate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__StandardBeginningDate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__StandardBeginningDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__StandardBeginningDate(soap, tag ? tag : "ns1:StandardBeginningDate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StandardBeginningDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StandardBeginningDate(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StandardBeginningDate * SOAP_FMAC4 soap_get_ns1__StandardBeginningDate(struct soap *soap, ns1__StandardBeginningDate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StandardBeginningDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__NumberQualifiers::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__decimal(soap, &this->ns1__NumberQualifiers::Digits);
	soap_default_xsd__decimal(soap, &this->ns1__NumberQualifiers::FractionDigits);
	soap_default_ns1__AllowedSign(soap, &this->ns1__NumberQualifiers::AllowedSign);
}

void ns1__NumberQualifiers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__NumberQualifiers::Digits, SOAP_TYPE_xsd__decimal);
	soap_serialize_xsd__decimal(soap, &this->ns1__NumberQualifiers::Digits);
	soap_embedded(soap, &this->ns1__NumberQualifiers::FractionDigits, SOAP_TYPE_xsd__decimal);
	soap_serialize_xsd__decimal(soap, &this->ns1__NumberQualifiers::FractionDigits);
#endif
}

int ns1__NumberQualifiers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NumberQualifiers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NumberQualifiers(struct soap *soap, const char *tag, int id, const ns1__NumberQualifiers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NumberQualifiers), type))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns1:Digits", -1, &a->ns1__NumberQualifiers::Digits, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns1:FractionDigits", -1, &a->ns1__NumberQualifiers::FractionDigits, ""))
		return soap->error;
	if (soap_out_ns1__AllowedSign(soap, "ns1:AllowedSign", -1, &a->ns1__NumberQualifiers::AllowedSign, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__NumberQualifiers::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__NumberQualifiers(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NumberQualifiers * SOAP_FMAC4 soap_in_ns1__NumberQualifiers(struct soap *soap, const char *tag, ns1__NumberQualifiers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NumberQualifiers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NumberQualifiers, sizeof(ns1__NumberQualifiers), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__NumberQualifiers)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__NumberQualifiers *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Digits1 = 1;
	size_t soap_flag_FractionDigits1 = 1;
	size_t soap_flag_AllowedSign1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Digits1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "ns1:Digits", &a->ns1__NumberQualifiers::Digits, "xsd:decimal"))
				{	soap_flag_Digits1--;
					continue;
				}
			}
			if (soap_flag_FractionDigits1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "ns1:FractionDigits", &a->ns1__NumberQualifiers::FractionDigits, "xsd:decimal"))
				{	soap_flag_FractionDigits1--;
					continue;
				}
			}
			if (soap_flag_AllowedSign1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__AllowedSign(soap, "ns1:AllowedSign", &a->ns1__NumberQualifiers::AllowedSign, "ns1:AllowedSign"))
				{	soap_flag_AllowedSign1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Digits1 > 0 || soap_flag_FractionDigits1 > 0 || soap_flag_AllowedSign1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__NumberQualifiers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NumberQualifiers, SOAP_TYPE_ns1__NumberQualifiers, sizeof(ns1__NumberQualifiers), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__NumberQualifiers * SOAP_FMAC2 soap_instantiate_ns1__NumberQualifiers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NumberQualifiers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__NumberQualifiers *p;
	size_t k = sizeof(ns1__NumberQualifiers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__NumberQualifiers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__NumberQualifiers);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__NumberQualifiers, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__NumberQualifiers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__NumberQualifiers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__NumberQualifiers(soap, tag ? tag : "ns1:NumberQualifiers", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NumberQualifiers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NumberQualifiers(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NumberQualifiers * SOAP_FMAC4 soap_get_ns1__NumberQualifiers(struct soap *soap, ns1__NumberQualifiers *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NumberQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Map::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__KeyAndValue(soap, &this->ns1__Map::pair);
}

void ns1__Map::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__KeyAndValue(soap, &this->ns1__Map::pair);
#endif
}

int ns1__Map::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Map(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Map(struct soap *soap, const char *tag, int id, const ns1__Map *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Map), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__KeyAndValue(soap, "ns1:pair", -1, &a->ns1__Map::pair, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Map::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Map(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Map * SOAP_FMAC4 soap_in_ns1__Map(struct soap *soap, const char *tag, ns1__Map *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Map*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Map, sizeof(ns1__Map), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Map)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Map *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__KeyAndValue(soap, "ns1:pair", &a->ns1__Map::pair, "ns1:KeyAndValue"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Map *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Map, SOAP_TYPE_ns1__Map, sizeof(ns1__Map), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Map * SOAP_FMAC2 soap_instantiate_ns1__Map(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Map(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Map *p;
	size_t k = sizeof(ns1__Map);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Map, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Map);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Map, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Map location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Map::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Map(soap, tag ? tag : "ns1:Map", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Map::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Map(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Map * SOAP_FMAC4 soap_get_ns1__Map(struct soap *soap, ns1__Map *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Map(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__LocalStringType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__LocalStringItemType(soap, &this->ns1__LocalStringType::item);
}

void ns1__LocalStringType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__LocalStringItemType(soap, &this->ns1__LocalStringType::item);
#endif
}

int ns1__LocalStringType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LocalStringType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LocalStringType(struct soap *soap, const char *tag, int id, const ns1__LocalStringType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LocalStringType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__LocalStringItemType(soap, "ns1:item", -1, &a->ns1__LocalStringType::item, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__LocalStringType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__LocalStringType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LocalStringType * SOAP_FMAC4 soap_in_ns1__LocalStringType(struct soap *soap, const char *tag, ns1__LocalStringType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LocalStringType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LocalStringType, sizeof(ns1__LocalStringType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__LocalStringType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__LocalStringType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__LocalStringItemType(soap, "ns1:item", &a->ns1__LocalStringType::item, "ns1:LocalStringItemType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__LocalStringType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LocalStringType, SOAP_TYPE_ns1__LocalStringType, sizeof(ns1__LocalStringType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__LocalStringType * SOAP_FMAC2 soap_instantiate_ns1__LocalStringType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LocalStringType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__LocalStringType *p;
	size_t k = sizeof(ns1__LocalStringType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__LocalStringType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__LocalStringType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__LocalStringType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__LocalStringType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__LocalStringType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__LocalStringType(soap, tag ? tag : "ns1:LocalStringType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LocalStringType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LocalStringType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LocalStringType * SOAP_FMAC4 soap_get_ns1__LocalStringType(struct soap *soap, ns1__LocalStringType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LocalStringType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__LocalStringItemType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__NMTOKEN(soap, &this->ns1__LocalStringItemType::lang);
	soap_default_std__string(soap, &this->ns1__LocalStringItemType::content);
}

void ns1__LocalStringItemType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__LocalStringItemType::lang, SOAP_TYPE_xsd__NMTOKEN);
	soap_serialize_xsd__NMTOKEN(soap, &this->ns1__LocalStringItemType::lang);
	soap_embedded(soap, &this->ns1__LocalStringItemType::content, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__LocalStringItemType::content);
#endif
}

int ns1__LocalStringItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LocalStringItemType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LocalStringItemType(struct soap *soap, const char *tag, int id, const ns1__LocalStringItemType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LocalStringItemType), type))
		return soap->error;
	if (soap_out_xsd__NMTOKEN(soap, "ns1:lang", -1, &a->ns1__LocalStringItemType::lang, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:content", -1, &a->ns1__LocalStringItemType::content, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__LocalStringItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__LocalStringItemType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LocalStringItemType * SOAP_FMAC4 soap_in_ns1__LocalStringItemType(struct soap *soap, const char *tag, ns1__LocalStringItemType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LocalStringItemType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LocalStringItemType, sizeof(ns1__LocalStringItemType), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__LocalStringItemType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__LocalStringItemType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_lang1 = 1;
	size_t soap_flag_content1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lang1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__NMTOKEN(soap, "ns1:lang", &a->ns1__LocalStringItemType::lang, "xsd:NMTOKEN"))
				{	soap_flag_lang1--;
					continue;
				}
			}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:content", &a->ns1__LocalStringItemType::content, "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lang1 > 0 || soap_flag_content1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__LocalStringItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LocalStringItemType, SOAP_TYPE_ns1__LocalStringItemType, sizeof(ns1__LocalStringItemType), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__LocalStringItemType * SOAP_FMAC2 soap_instantiate_ns1__LocalStringItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LocalStringItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__LocalStringItemType *p;
	size_t k = sizeof(ns1__LocalStringItemType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__LocalStringItemType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__LocalStringItemType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__LocalStringItemType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__LocalStringItemType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__LocalStringItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__LocalStringItemType(soap, tag ? tag : "ns1:LocalStringItemType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LocalStringItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LocalStringItemType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LocalStringItemType * SOAP_FMAC4 soap_get_ns1__LocalStringItemType(struct soap *soap, ns1__LocalStringItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LocalStringItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__KeyAndValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__KeyAndValue::Key = NULL;
	this->ns1__KeyAndValue::Value = NULL;
}

void ns1__KeyAndValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__KeyAndValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__KeyAndValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__KeyAndValue(struct soap *soap, const char *tag, int id, const ns1__KeyAndValue *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__KeyAndValue), type))
		return soap->error;
	if (!a->ns1__KeyAndValue::Key)
	{	if (soap_element_empty(soap, "ns1:Key"))
			return soap->error;
	}
	else if (soap_outliteral(soap, "ns1:Key", (char*const*)&a->ns1__KeyAndValue::Key, NULL))
		return soap->error;
	if (!a->ns1__KeyAndValue::Value)
	{	if (soap_element_nil(soap, "ns1:Value"))
			return soap->error;
	}
	else if (soap_outliteral(soap, "ns1:Value", (char*const*)&a->ns1__KeyAndValue::Value, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__KeyAndValue::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__KeyAndValue(soap, tag, this, type);
}

SOAP_FMAC3 ns1__KeyAndValue * SOAP_FMAC4 soap_in_ns1__KeyAndValue(struct soap *soap, const char *tag, ns1__KeyAndValue *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__KeyAndValue*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__KeyAndValue, sizeof(ns1__KeyAndValue), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__KeyAndValue)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__KeyAndValue *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Value1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns1:Key", (char**)&a->ns1__KeyAndValue::Key))
				{	soap_flag_Key1--;
					continue;
				}
			}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "ns1:Value", (char**)&a->ns1__KeyAndValue::Value))
				{	soap_flag_Value1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns1__KeyAndValue::Key || soap_flag_Value1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__KeyAndValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__KeyAndValue, SOAP_TYPE_ns1__KeyAndValue, sizeof(ns1__KeyAndValue), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__KeyAndValue * SOAP_FMAC2 soap_instantiate_ns1__KeyAndValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__KeyAndValue(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__KeyAndValue *p;
	size_t k = sizeof(ns1__KeyAndValue);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__KeyAndValue, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__KeyAndValue);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__KeyAndValue, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__KeyAndValue location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__KeyAndValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__KeyAndValue(soap, tag ? tag : "ns1:KeyAndValue", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__KeyAndValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__KeyAndValue(soap, this, tag, type);
}

SOAP_FMAC3 ns1__KeyAndValue * SOAP_FMAC4 soap_get_ns1__KeyAndValue(struct soap *soap, ns1__KeyAndValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__KeyAndValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__GenericException::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__GenericException::descr);
	this->ns1__GenericException::inner = NULL;
	soap_default_ns1__UUID(soap, &this->ns1__GenericException::clsid);
	this->ns1__GenericException::encoded = (bool)0;
}

void ns1__GenericException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__GenericException::descr, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__GenericException::descr);
	soap_serialize_PointerTons1__GenericException(soap, &this->ns1__GenericException::inner);
#endif
}

int ns1__GenericException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GenericException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenericException(struct soap *soap, const char *tag, int id, const ns1__GenericException *a, const char *type)
{
	soap_set_attr(soap, "clsid", soap_ns1__UUID2s(soap, ((ns1__GenericException*)a)->clsid), 1);
	if (((ns1__GenericException*)a)->encoded != (bool)0)
	{	soap_set_attr(soap, "encoded", soap_bool2s(soap, ((ns1__GenericException*)a)->encoded), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenericException), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:descr", -1, &a->ns1__GenericException::descr, ""))
		return soap->error;
	if (soap_out_PointerTons1__GenericException(soap, "ns1:inner", -1, &a->ns1__GenericException::inner, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GenericException::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__GenericException(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GenericException * SOAP_FMAC4 soap_in_ns1__GenericException(struct soap *soap, const char *tag, ns1__GenericException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GenericException*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenericException, sizeof(ns1__GenericException), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__GenericException)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__GenericException *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns1__UUID(soap, soap_attr_value(soap, "clsid", 1, 1), &((ns1__GenericException*)a)->clsid))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "encoded", 5, 0), &((ns1__GenericException*)a)->encoded))
		return NULL;
	size_t soap_flag_descr1 = 1;
	size_t soap_flag_inner1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_descr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:descr", &a->ns1__GenericException::descr, "xsd:string"))
				{	soap_flag_descr1--;
					continue;
				}
			}
			if (soap_flag_inner1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenericException(soap, "ns1:inner", &a->ns1__GenericException::inner, "ns1:GenericException"))
				{	soap_flag_inner1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_descr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__GenericException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenericException, SOAP_TYPE_ns1__GenericException, sizeof(ns1__GenericException), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__GenericException * SOAP_FMAC2 soap_instantiate_ns1__GenericException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenericException(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns1:Exception"))
		return soap_instantiate_ns1__Exception(soap, n, NULL, NULL, size);
	ns1__GenericException *p;
	size_t k = sizeof(ns1__GenericException);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GenericException, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__GenericException);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__GenericException, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__GenericException location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__GenericException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__GenericException(soap, tag ? tag : "ns1:GenericException", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GenericException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GenericException(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GenericException * SOAP_FMAC4 soap_get_ns1__GenericException(struct soap *soap, ns1__GenericException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GenericException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FixedStructure::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_ns1__FixedStructure_Property(soap, &this->ns1__FixedStructure::Property);
}

void ns1__FixedStructure::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_ns1__FixedStructure_Property(soap, &this->ns1__FixedStructure::Property);
#endif
}

int ns1__FixedStructure::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FixedStructure(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FixedStructure(struct soap *soap, const char *tag, int id, const ns1__FixedStructure *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FixedStructure), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_ns1__FixedStructure_Property(soap, "ns1:Property", -1, &a->ns1__FixedStructure::Property, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FixedStructure::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FixedStructure(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FixedStructure * SOAP_FMAC4 soap_in_ns1__FixedStructure(struct soap *soap, const char *tag, ns1__FixedStructure *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FixedStructure*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FixedStructure, sizeof(ns1__FixedStructure), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FixedStructure)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FixedStructure *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_ns1__FixedStructure_Property(soap, "ns1:Property", &a->ns1__FixedStructure::Property, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__FixedStructure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FixedStructure, SOAP_TYPE_ns1__FixedStructure, sizeof(ns1__FixedStructure), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FixedStructure * SOAP_FMAC2 soap_instantiate_ns1__FixedStructure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FixedStructure(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FixedStructure *p;
	size_t k = sizeof(ns1__FixedStructure);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FixedStructure, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FixedStructure);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FixedStructure, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FixedStructure location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FixedStructure::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FixedStructure(soap, tag ? tag : "ns1:FixedStructure", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FixedStructure::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FixedStructure(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FixedStructure * SOAP_FMAC4 soap_get_ns1__FixedStructure(struct soap *soap, ns1__FixedStructure *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FixedStructure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FixedMap::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__KeyAndValue(soap, &this->ns1__FixedMap::pair);
}

void ns1__FixedMap::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__KeyAndValue(soap, &this->ns1__FixedMap::pair);
#endif
}

int ns1__FixedMap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FixedMap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FixedMap(struct soap *soap, const char *tag, int id, const ns1__FixedMap *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FixedMap), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__KeyAndValue(soap, "ns1:pair", -1, &a->ns1__FixedMap::pair, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FixedMap::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FixedMap(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FixedMap * SOAP_FMAC4 soap_in_ns1__FixedMap(struct soap *soap, const char *tag, ns1__FixedMap *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FixedMap*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FixedMap, sizeof(ns1__FixedMap), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FixedMap)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FixedMap *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__KeyAndValue(soap, "ns1:pair", &a->ns1__FixedMap::pair, "ns1:KeyAndValue"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__FixedMap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FixedMap, SOAP_TYPE_ns1__FixedMap, sizeof(ns1__FixedMap), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FixedMap * SOAP_FMAC2 soap_instantiate_ns1__FixedMap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FixedMap(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FixedMap *p;
	size_t k = sizeof(ns1__FixedMap);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FixedMap, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FixedMap);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FixedMap, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FixedMap location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FixedMap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FixedMap(soap, tag ? tag : "ns1:FixedMap", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FixedMap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FixedMap(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FixedMap * SOAP_FMAC4 soap_get_ns1__FixedMap(struct soap *soap, ns1__FixedMap *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FixedMap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FixedArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns1__FixedArray::Value);
}

void ns1__FixedArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns1__FixedArray::Value);
#endif
}

int ns1__FixedArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FixedArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FixedArray(struct soap *soap, const char *tag, int id, const ns1__FixedArray *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FixedArray), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "ns1:Value", -1, &a->ns1__FixedArray::Value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FixedArray::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__FixedArray(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FixedArray * SOAP_FMAC4 soap_in_ns1__FixedArray(struct soap *soap, const char *tag, ns1__FixedArray *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FixedArray*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FixedArray, sizeof(ns1__FixedArray), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FixedArray)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FixedArray *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "ns1:Value", &a->ns1__FixedArray::Value, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__FixedArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FixedArray, SOAP_TYPE_ns1__FixedArray, sizeof(ns1__FixedArray), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FixedArray * SOAP_FMAC2 soap_instantiate_ns1__FixedArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FixedArray(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FixedArray *p;
	size_t k = sizeof(ns1__FixedArray);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FixedArray, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FixedArray);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FixedArray, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FixedArray location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FixedArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FixedArray(soap, tag ? tag : "ns1:FixedArray", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FixedArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FixedArray(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FixedArray * SOAP_FMAC4 soap_get_ns1__FixedArray(struct soap *soap, ns1__FixedArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FixedArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Exception::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__GenericException::soap_default(soap);
	this->ns1__Exception::data = NULL;
}

void ns1__Exception::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns1__Exception::data);
	this->ns1__GenericException::soap_serialize(soap);
#endif
}

int ns1__Exception::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Exception(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Exception(struct soap *soap, const char *tag, int id, const ns1__Exception *a, const char *type)
{
	soap_set_attr(soap, "clsid", soap_ns1__UUID2s(soap, ((ns1__GenericException*)a)->clsid), 1);
	if (((ns1__GenericException*)a)->encoded != (bool)0)
	{	soap_set_attr(soap, "encoded", soap_bool2s(soap, ((ns1__GenericException*)a)->encoded), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Exception), type ? type : "ns1:Exception"))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:descr", -1, &a->ns1__GenericException::descr, ""))
		return soap->error;
	if (soap_out_PointerTons1__GenericException(soap, "ns1:inner", -1, &a->ns1__GenericException::inner, ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "ns1:data", -1, &a->ns1__Exception::data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Exception::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Exception(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Exception * SOAP_FMAC4 soap_in_ns1__Exception(struct soap *soap, const char *tag, ns1__Exception *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Exception*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Exception, sizeof(ns1__Exception), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Exception)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Exception *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns1__UUID(soap, soap_attr_value(soap, "clsid", 1, 1), &((ns1__GenericException*)a)->clsid))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "encoded", 5, 0), &((ns1__GenericException*)a)->encoded))
		return NULL;
	size_t soap_flag_descr2 = 1;
	size_t soap_flag_inner2 = 1;
	size_t soap_flag_data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_descr2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:descr", &a->ns1__GenericException::descr, "xsd:string"))
				{	soap_flag_descr2--;
					continue;
				}
			}
			if (soap_flag_inner2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__GenericException(soap, "ns1:inner", &a->ns1__GenericException::inner, "ns1:GenericException"))
				{	soap_flag_inner2--;
					continue;
				}
			}
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__base64Binary(soap, "ns1:data", &a->ns1__Exception::data, "xsd:base64Binary"))
				{	soap_flag_data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_descr2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Exception *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Exception, SOAP_TYPE_ns1__Exception, sizeof(ns1__Exception), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Exception * SOAP_FMAC2 soap_instantiate_ns1__Exception(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Exception(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Exception *p;
	size_t k = sizeof(ns1__Exception);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Exception, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Exception);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Exception, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Exception location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Exception::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Exception(soap, tag ? tag : "ns1:Exception", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Exception::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Exception(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Exception * SOAP_FMAC4 soap_get_ns1__Exception(struct soap *soap, ns1__Exception *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Exception(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DateQualifiers::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__DateFractions(soap, &this->ns1__DateQualifiers::DateFractions);
}

void ns1__DateQualifiers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__DateQualifiers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DateQualifiers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DateQualifiers(struct soap *soap, const char *tag, int id, const ns1__DateQualifiers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DateQualifiers), type))
		return soap->error;
	if (soap_out_ns1__DateFractions(soap, "ns1:DateFractions", -1, &a->ns1__DateQualifiers::DateFractions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DateQualifiers::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DateQualifiers(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DateQualifiers * SOAP_FMAC4 soap_in_ns1__DateQualifiers(struct soap *soap, const char *tag, ns1__DateQualifiers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DateQualifiers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DateQualifiers, sizeof(ns1__DateQualifiers), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DateQualifiers)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DateQualifiers *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DateFractions1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateFractions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__DateFractions(soap, "ns1:DateFractions", &a->ns1__DateQualifiers::DateFractions, "ns1:DateFractions"))
				{	soap_flag_DateFractions1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateFractions1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__DateQualifiers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DateQualifiers, SOAP_TYPE_ns1__DateQualifiers, sizeof(ns1__DateQualifiers), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DateQualifiers * SOAP_FMAC2 soap_instantiate_ns1__DateQualifiers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DateQualifiers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DateQualifiers *p;
	size_t k = sizeof(ns1__DateQualifiers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DateQualifiers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DateQualifiers);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DateQualifiers, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DateQualifiers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DateQualifiers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DateQualifiers(soap, tag ? tag : "ns1:DateQualifiers", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DateQualifiers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DateQualifiers(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DateQualifiers * SOAP_FMAC4 soap_get_ns1__DateQualifiers(struct soap *soap, ns1__DateQualifiers *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DateQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DataFillErrors::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__DataFillError(soap, &this->ns1__DataFillErrors::item);
}

void ns1__DataFillErrors::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__DataFillError(soap, &this->ns1__DataFillErrors::item);
#endif
}

int ns1__DataFillErrors::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DataFillErrors(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataFillErrors(struct soap *soap, const char *tag, int id, const ns1__DataFillErrors *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataFillErrors), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__DataFillError(soap, "ns1:item", -1, &a->ns1__DataFillErrors::item, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DataFillErrors::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DataFillErrors(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DataFillErrors * SOAP_FMAC4 soap_in_ns1__DataFillErrors(struct soap *soap, const char *tag, ns1__DataFillErrors *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DataFillErrors*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataFillErrors, sizeof(ns1__DataFillErrors), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DataFillErrors)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DataFillErrors *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__DataFillError(soap, "ns1:item", &a->ns1__DataFillErrors::item, "ns1:DataFillError"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DataFillErrors *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataFillErrors, SOAP_TYPE_ns1__DataFillErrors, sizeof(ns1__DataFillErrors), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DataFillErrors * SOAP_FMAC2 soap_instantiate_ns1__DataFillErrors(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DataFillErrors(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DataFillErrors *p;
	size_t k = sizeof(ns1__DataFillErrors);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DataFillErrors, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DataFillErrors);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DataFillErrors, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DataFillErrors location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DataFillErrors::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DataFillErrors(soap, tag ? tag : "ns1:DataFillErrors", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DataFillErrors::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DataFillErrors(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DataFillErrors * SOAP_FMAC4 soap_get_ns1__DataFillErrors(struct soap *soap, ns1__DataFillErrors *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DataFillErrors(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DataFillError::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__DataFillError::Data);
	soap_default_std__string(soap, &this->ns1__DataFillError::DataDescr);
	soap_default_std__string(soap, &this->ns1__DataFillError::Text);
	soap_default_ns1__FillCheckErrorStatus(soap, &this->ns1__DataFillError::Status);
}

void ns1__DataFillError::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__DataFillError::Data, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DataFillError::Data);
	soap_embedded(soap, &this->ns1__DataFillError::DataDescr, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DataFillError::DataDescr);
	soap_embedded(soap, &this->ns1__DataFillError::Text, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DataFillError::Text);
#endif
}

int ns1__DataFillError::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DataFillError(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataFillError(struct soap *soap, const char *tag, int id, const ns1__DataFillError *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataFillError), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Data", -1, &a->ns1__DataFillError::Data, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:DataDescr", -1, &a->ns1__DataFillError::DataDescr, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Text", -1, &a->ns1__DataFillError::Text, ""))
		return soap->error;
	if (soap_out_ns1__FillCheckErrorStatus(soap, "ns1:Status", -1, &a->ns1__DataFillError::Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DataFillError::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DataFillError(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DataFillError * SOAP_FMAC4 soap_in_ns1__DataFillError(struct soap *soap, const char *tag, ns1__DataFillError *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DataFillError*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataFillError, sizeof(ns1__DataFillError), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DataFillError)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DataFillError *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Data1 = 1;
	size_t soap_flag_DataDescr1 = 1;
	size_t soap_flag_Text1 = 1;
	size_t soap_flag_Status1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:Data", &a->ns1__DataFillError::Data, "xsd:string"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap_flag_DataDescr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:DataDescr", &a->ns1__DataFillError::DataDescr, "xsd:string"))
				{	soap_flag_DataDescr1--;
					continue;
				}
			}
			if (soap_flag_Text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ns1:Text", &a->ns1__DataFillError::Text, "xsd:string"))
				{	soap_flag_Text1--;
					continue;
				}
			}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__FillCheckErrorStatus(soap, "ns1:Status", &a->ns1__DataFillError::Status, "ns1:FillCheckErrorStatus"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0 || soap_flag_DataDescr1 > 0 || soap_flag_Text1 > 0 || soap_flag_Status1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__DataFillError *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataFillError, SOAP_TYPE_ns1__DataFillError, sizeof(ns1__DataFillError), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DataFillError * SOAP_FMAC2 soap_instantiate_ns1__DataFillError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DataFillError(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DataFillError *p;
	size_t k = sizeof(ns1__DataFillError);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DataFillError, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DataFillError);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DataFillError, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DataFillError location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DataFillError::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DataFillError(soap, tag ? tag : "ns1:DataFillError", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DataFillError::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DataFillError(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DataFillError * SOAP_FMAC4 soap_get_ns1__DataFillError(struct soap *soap, ns1__DataFillError *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DataFillError(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__BinaryDataQualifiers::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__decimal(soap, &this->ns1__BinaryDataQualifiers::Length);
	soap_default_ns1__AllowedLength(soap, &this->ns1__BinaryDataQualifiers::AllowedLength);
}

void ns1__BinaryDataQualifiers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__BinaryDataQualifiers::Length, SOAP_TYPE_xsd__decimal);
	soap_serialize_xsd__decimal(soap, &this->ns1__BinaryDataQualifiers::Length);
#endif
}

int ns1__BinaryDataQualifiers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BinaryDataQualifiers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BinaryDataQualifiers(struct soap *soap, const char *tag, int id, const ns1__BinaryDataQualifiers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BinaryDataQualifiers), type))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns1:Length", -1, &a->ns1__BinaryDataQualifiers::Length, ""))
		return soap->error;
	if (soap_out_ns1__AllowedLength(soap, "ns1:AllowedLength", -1, &a->ns1__BinaryDataQualifiers::AllowedLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__BinaryDataQualifiers::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__BinaryDataQualifiers(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BinaryDataQualifiers * SOAP_FMAC4 soap_in_ns1__BinaryDataQualifiers(struct soap *soap, const char *tag, ns1__BinaryDataQualifiers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BinaryDataQualifiers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BinaryDataQualifiers, sizeof(ns1__BinaryDataQualifiers), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__BinaryDataQualifiers)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__BinaryDataQualifiers *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Length1 = 1;
	size_t soap_flag_AllowedLength1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Length1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "ns1:Length", &a->ns1__BinaryDataQualifiers::Length, "xsd:decimal"))
				{	soap_flag_Length1--;
					continue;
				}
			}
			if (soap_flag_AllowedLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__AllowedLength(soap, "ns1:AllowedLength", &a->ns1__BinaryDataQualifiers::AllowedLength, "ns1:AllowedLength"))
				{	soap_flag_AllowedLength1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Length1 > 0 || soap_flag_AllowedLength1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__BinaryDataQualifiers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BinaryDataQualifiers, SOAP_TYPE_ns1__BinaryDataQualifiers, sizeof(ns1__BinaryDataQualifiers), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__BinaryDataQualifiers * SOAP_FMAC2 soap_instantiate_ns1__BinaryDataQualifiers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BinaryDataQualifiers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__BinaryDataQualifiers *p;
	size_t k = sizeof(ns1__BinaryDataQualifiers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__BinaryDataQualifiers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__BinaryDataQualifiers);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__BinaryDataQualifiers, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__BinaryDataQualifiers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__BinaryDataQualifiers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__BinaryDataQualifiers(soap, tag ? tag : "ns1:BinaryDataQualifiers", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BinaryDataQualifiers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BinaryDataQualifiers(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BinaryDataQualifiers * SOAP_FMAC4 soap_get_ns1__BinaryDataQualifiers(struct soap *soap, ns1__BinaryDataQualifiers *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BinaryDataQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Array::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns1__Array::Value);
}

void ns1__Array::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns1__Array::Value);
#endif
}

int ns1__Array::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Array(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Array(struct soap *soap, const char *tag, int id, const ns1__Array *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Array), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "ns1:Value", -1, &a->ns1__Array::Value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Array::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Array(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Array * SOAP_FMAC4 soap_in_ns1__Array(struct soap *soap, const char *tag, ns1__Array *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Array*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Array, sizeof(ns1__Array), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Array)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Array *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "ns1:Value", &a->ns1__Array::Value, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Array *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Array, SOAP_TYPE_ns1__Array, sizeof(ns1__Array), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Array * SOAP_FMAC2 soap_instantiate_ns1__Array(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Array(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Array *p;
	size_t k = sizeof(ns1__Array);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Array, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Array);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Array, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Array location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Array::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Array(soap, tag ? tag : "ns1:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Array::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Array(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Array * SOAP_FMAC4 soap_get_ns1__Array(struct soap *soap, ns1__Array *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Array(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "\\+?\\d+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__nonNegativeInteger, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?(\\d+|\\d*\\.\\d*)")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__decimal, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NMTOKEN(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NMTOKEN(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NMTOKEN), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__NMTOKEN(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "\\c+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__NMTOKEN, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NMTOKEN(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__NMTOKEN(soap, tag ? tag : "xsd:NMTOKEN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NMTOKEN(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NMTOKEN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_attachment_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__base64Binary, this->id, this->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary *p;
	size_t k = sizeof(xsd__base64Binary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__base64Binary);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__base64Binary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 2, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__QName, SOAP_TYPE_xsd__QName, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__QName(soap, tag ? tag : "xsd:QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__MozaicAuthorization_(struct soap *soap, struct __ns1__MozaicAuthorization_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__MozaicAuthorization = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__MozaicAuthorization_(struct soap *soap, const struct __ns1__MozaicAuthorization_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__MozaicAuthorization(soap, &a->ns1__MozaicAuthorization);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__MozaicAuthorization_(struct soap *soap, const char *tag, int id, const struct __ns1__MozaicAuthorization_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__MozaicAuthorization(soap, "ns1:MozaicAuthorization", -1, &a->ns1__MozaicAuthorization, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MozaicAuthorization_ * SOAP_FMAC4 soap_in___ns1__MozaicAuthorization_(struct soap *soap, const char *tag, struct __ns1__MozaicAuthorization_ *a, const char *type)
{
	size_t soap_flag_ns1__MozaicAuthorization = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__MozaicAuthorization_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__MozaicAuthorization_, sizeof(struct __ns1__MozaicAuthorization_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__MozaicAuthorization_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__MozaicAuthorization && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__MozaicAuthorization(soap, "ns1:MozaicAuthorization", &a->ns1__MozaicAuthorization, ""))
				{	soap_flag_ns1__MozaicAuthorization--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__MozaicAuthorization_ * SOAP_FMAC2 soap_instantiate___ns1__MozaicAuthorization_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__MozaicAuthorization_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__MozaicAuthorization_ *p;
	size_t k = sizeof(struct __ns1__MozaicAuthorization_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__MozaicAuthorization_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__MozaicAuthorization_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__MozaicAuthorization_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__MozaicAuthorization_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__MozaicAuthorization_(struct soap *soap, const struct __ns1__MozaicAuthorization_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__MozaicAuthorization_(soap, tag ? tag : "-ns1:MozaicAuthorization", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MozaicAuthorization_ * SOAP_FMAC4 soap_get___ns1__MozaicAuthorization_(struct soap *soap, struct __ns1__MozaicAuthorization_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__MozaicAuthorization_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__СинхронизацияСправочнойИнформации_(struct soap *soap, struct __ns1__СинхронизацияСправочнойИнформации_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__СинхронизацияСправочнойИнформации = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__СинхронизацияСправочнойИнформации_(struct soap *soap, const struct __ns1__СинхронизацияСправочнойИнформации_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__СинхронизацияСправочнойИнформации(soap, &a->ns1__СинхронизацияСправочнойИнформации);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__СинхронизацияСправочнойИнформации_(struct soap *soap, const char *tag, int id, const struct __ns1__СинхронизацияСправочнойИнформации_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__СинхронизацияСправочнойИнформации(soap, "ns1:СинхронизацияСправочнойИнформации", -1, &a->ns1__СинхронизацияСправочнойИнформации, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__СинхронизацияСправочнойИнформации_ * SOAP_FMAC4 soap_in___ns1__СинхронизацияСправочнойИнформации_(struct soap *soap, const char *tag, struct __ns1__СинхронизацияСправочнойИнформации_ *a, const char *type)
{
	size_t soap_flag_ns1__СинхронизацияСправочнойИнформации = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__СинхронизацияСправочнойИнформации_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__СинхронизацияСправочнойИнформации_, sizeof(struct __ns1__СинхронизацияСправочнойИнформации_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__СинхронизацияСправочнойИнформации_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__СинхронизацияСправочнойИнформации && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__СинхронизацияСправочнойИнформации(soap, "ns1:СинхронизацияСправочнойИнформации", &a->ns1__СинхронизацияСправочнойИнформации, ""))
				{	soap_flag_ns1__СинхронизацияСправочнойИнформации--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__СинхронизацияСправочнойИнформации_ * SOAP_FMAC2 soap_instantiate___ns1__СинхронизацияСправочнойИнформации_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__СинхронизацияСправочнойИнформации_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__СинхронизацияСправочнойИнформации_ *p;
	size_t k = sizeof(struct __ns1__СинхронизацияСправочнойИнформации_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__СинхронизацияСправочнойИнформации_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__СинхронизацияСправочнойИнформации_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__СинхронизацияСправочнойИнформации_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__СинхронизацияСправочнойИнформации_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__СинхронизацияСправочнойИнформации_(struct soap *soap, const struct __ns1__СинхронизацияСправочнойИнформации_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__СинхронизацияСправочнойИнформации_(soap, tag ? tag : "-ns1:СинхронизацияСправочнойИнформации", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__СинхронизацияСправочнойИнформации_ * SOAP_FMAC4 soap_get___ns1__СинхронизацияСправочнойИнформации_(struct soap *soap, struct __ns1__СинхронизацияСправочнойИнформации_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__СинхронизацияСправочнойИнформации_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ВыгрузкаСправочнойИнформации_(struct soap *soap, struct __ns1__ВыгрузкаСправочнойИнформации_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ВыгрузкаСправочнойИнформации = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ВыгрузкаСправочнойИнформации_(struct soap *soap, const struct __ns1__ВыгрузкаСправочнойИнформации_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ВыгрузкаСправочнойИнформации(soap, &a->ns1__ВыгрузкаСправочнойИнформации);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ВыгрузкаСправочнойИнформации_(struct soap *soap, const char *tag, int id, const struct __ns1__ВыгрузкаСправочнойИнформации_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ВыгрузкаСправочнойИнформации(soap, "ns1:ВыгрузкаСправочнойИнформации", -1, &a->ns1__ВыгрузкаСправочнойИнформации, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ВыгрузкаСправочнойИнформации_ * SOAP_FMAC4 soap_in___ns1__ВыгрузкаСправочнойИнформации_(struct soap *soap, const char *tag, struct __ns1__ВыгрузкаСправочнойИнформации_ *a, const char *type)
{
	size_t soap_flag_ns1__ВыгрузкаСправочнойИнформации = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ВыгрузкаСправочнойИнформации_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ВыгрузкаСправочнойИнформации_, sizeof(struct __ns1__ВыгрузкаСправочнойИнформации_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ВыгрузкаСправочнойИнформации_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ВыгрузкаСправочнойИнформации && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ВыгрузкаСправочнойИнформации(soap, "ns1:ВыгрузкаСправочнойИнформации", &a->ns1__ВыгрузкаСправочнойИнформации, ""))
				{	soap_flag_ns1__ВыгрузкаСправочнойИнформации--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ВыгрузкаСправочнойИнформации_ * SOAP_FMAC2 soap_instantiate___ns1__ВыгрузкаСправочнойИнформации_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ВыгрузкаСправочнойИнформации_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ВыгрузкаСправочнойИнформации_ *p;
	size_t k = sizeof(struct __ns1__ВыгрузкаСправочнойИнформации_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ВыгрузкаСправочнойИнформации_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ВыгрузкаСправочнойИнформации_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ВыгрузкаСправочнойИнформации_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ВыгрузкаСправочнойИнформации_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ВыгрузкаСправочнойИнформации_(struct soap *soap, const struct __ns1__ВыгрузкаСправочнойИнформации_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ВыгрузкаСправочнойИнформации_(soap, tag ? tag : "-ns1:ВыгрузкаСправочнойИнформации", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ВыгрузкаСправочнойИнформации_ * SOAP_FMAC4 soap_get___ns1__ВыгрузкаСправочнойИнформации_(struct soap *soap, struct __ns1__ВыгрузкаСправочнойИнформации_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ВыгрузкаСправочнойИнформации_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ПринятьПакетОбмена_(struct soap *soap, struct __ns1__ПринятьПакетОбмена_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ПринятьПакетОбмена = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ПринятьПакетОбмена_(struct soap *soap, const struct __ns1__ПринятьПакетОбмена_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ПринятьПакетОбмена(soap, &a->ns1__ПринятьПакетОбмена);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ПринятьПакетОбмена_(struct soap *soap, const char *tag, int id, const struct __ns1__ПринятьПакетОбмена_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ПринятьПакетОбмена(soap, "ns1:ПринятьПакетОбмена", -1, &a->ns1__ПринятьПакетОбмена, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ПринятьПакетОбмена_ * SOAP_FMAC4 soap_in___ns1__ПринятьПакетОбмена_(struct soap *soap, const char *tag, struct __ns1__ПринятьПакетОбмена_ *a, const char *type)
{
	size_t soap_flag_ns1__ПринятьПакетОбмена = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ПринятьПакетОбмена_*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ПринятьПакетОбмена_, sizeof(struct __ns1__ПринятьПакетОбмена_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ПринятьПакетОбмена_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ПринятьПакетОбмена && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ПринятьПакетОбмена(soap, "ns1:ПринятьПакетОбмена", &a->ns1__ПринятьПакетОбмена, ""))
				{	soap_flag_ns1__ПринятьПакетОбмена--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ПринятьПакетОбмена_ * SOAP_FMAC2 soap_instantiate___ns1__ПринятьПакетОбмена_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ПринятьПакетОбмена_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ПринятьПакетОбмена_ *p;
	size_t k = sizeof(struct __ns1__ПринятьПакетОбмена_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ПринятьПакетОбмена_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ПринятьПакетОбмена_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ПринятьПакетОбмена_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ПринятьПакетОбмена_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ПринятьПакетОбмена_(struct soap *soap, const struct __ns1__ПринятьПакетОбмена_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ПринятьПакетОбмена_(soap, tag ? tag : "-ns1:ПринятьПакетОбмена", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ПринятьПакетОбмена_ * SOAP_FMAC4 soap_get___ns1__ПринятьПакетОбмена_(struct soap *soap, struct __ns1__ПринятьПакетОбмена_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ПринятьПакетОбмена_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__MozaicAuthorization(struct soap *soap, struct __ns1__MozaicAuthorization *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__MozaicAuthorization = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__MozaicAuthorization(struct soap *soap, const struct __ns1__MozaicAuthorization *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__MozaicAuthorization(soap, &a->ns1__MozaicAuthorization);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__MozaicAuthorization(struct soap *soap, const char *tag, int id, const struct __ns1__MozaicAuthorization *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__MozaicAuthorization(soap, "ns1:MozaicAuthorization", -1, &a->ns1__MozaicAuthorization, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MozaicAuthorization * SOAP_FMAC4 soap_in___ns1__MozaicAuthorization(struct soap *soap, const char *tag, struct __ns1__MozaicAuthorization *a, const char *type)
{
	size_t soap_flag_ns1__MozaicAuthorization = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__MozaicAuthorization*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__MozaicAuthorization, sizeof(struct __ns1__MozaicAuthorization), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__MozaicAuthorization(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__MozaicAuthorization && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__MozaicAuthorization(soap, "ns1:MozaicAuthorization", &a->ns1__MozaicAuthorization, ""))
				{	soap_flag_ns1__MozaicAuthorization--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__MozaicAuthorization * SOAP_FMAC2 soap_instantiate___ns1__MozaicAuthorization(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__MozaicAuthorization(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__MozaicAuthorization *p;
	size_t k = sizeof(struct __ns1__MozaicAuthorization);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__MozaicAuthorization, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__MozaicAuthorization);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__MozaicAuthorization, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__MozaicAuthorization location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__MozaicAuthorization(struct soap *soap, const struct __ns1__MozaicAuthorization *a, const char *tag, const char *type)
{
	if (soap_out___ns1__MozaicAuthorization(soap, tag ? tag : "-ns1:MozaicAuthorization", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MozaicAuthorization * SOAP_FMAC4 soap_get___ns1__MozaicAuthorization(struct soap *soap, struct __ns1__MozaicAuthorization *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__MozaicAuthorization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__СинхронизацияСправочнойИнформации(struct soap *soap, struct __ns1__СинхронизацияСправочнойИнформации *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__СинхронизацияСправочнойИнформации = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__СинхронизацияСправочнойИнформации(struct soap *soap, const struct __ns1__СинхронизацияСправочнойИнформации *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__СинхронизацияСправочнойИнформации(soap, &a->ns1__СинхронизацияСправочнойИнформации);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__СинхронизацияСправочнойИнформации(struct soap *soap, const char *tag, int id, const struct __ns1__СинхронизацияСправочнойИнформации *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__СинхронизацияСправочнойИнформации(soap, "ns1:СинхронизацияСправочнойИнформации", -1, &a->ns1__СинхронизацияСправочнойИнформации, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__СинхронизацияСправочнойИнформации * SOAP_FMAC4 soap_in___ns1__СинхронизацияСправочнойИнформации(struct soap *soap, const char *tag, struct __ns1__СинхронизацияСправочнойИнформации *a, const char *type)
{
	size_t soap_flag_ns1__СинхронизацияСправочнойИнформации = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__СинхронизацияСправочнойИнформации*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__СинхронизацияСправочнойИнформации, sizeof(struct __ns1__СинхронизацияСправочнойИнформации), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__СинхронизацияСправочнойИнформации(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__СинхронизацияСправочнойИнформации && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__СинхронизацияСправочнойИнформации(soap, "ns1:СинхронизацияСправочнойИнформации", &a->ns1__СинхронизацияСправочнойИнформации, ""))
				{	soap_flag_ns1__СинхронизацияСправочнойИнформации--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__СинхронизацияСправочнойИнформации * SOAP_FMAC2 soap_instantiate___ns1__СинхронизацияСправочнойИнформации(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__СинхронизацияСправочнойИнформации(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__СинхронизацияСправочнойИнформации *p;
	size_t k = sizeof(struct __ns1__СинхронизацияСправочнойИнформации);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__СинхронизацияСправочнойИнформации, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__СинхронизацияСправочнойИнформации);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__СинхронизацияСправочнойИнформации, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__СинхронизацияСправочнойИнформации location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__СинхронизацияСправочнойИнформации(struct soap *soap, const struct __ns1__СинхронизацияСправочнойИнформации *a, const char *tag, const char *type)
{
	if (soap_out___ns1__СинхронизацияСправочнойИнформации(soap, tag ? tag : "-ns1:СинхронизацияСправочнойИнформации", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__СинхронизацияСправочнойИнформации * SOAP_FMAC4 soap_get___ns1__СинхронизацияСправочнойИнформации(struct soap *soap, struct __ns1__СинхронизацияСправочнойИнформации *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__СинхронизацияСправочнойИнформации(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, struct __ns1__ВыгрузкаСправочнойИнформации *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ВыгрузкаСправочнойИнформации = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, const struct __ns1__ВыгрузкаСправочнойИнформации *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ВыгрузкаСправочнойИнформации(soap, &a->ns1__ВыгрузкаСправочнойИнформации);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, const char *tag, int id, const struct __ns1__ВыгрузкаСправочнойИнформации *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ВыгрузкаСправочнойИнформации(soap, "ns1:ВыгрузкаСправочнойИнформации", -1, &a->ns1__ВыгрузкаСправочнойИнформации, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ВыгрузкаСправочнойИнформации * SOAP_FMAC4 soap_in___ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, const char *tag, struct __ns1__ВыгрузкаСправочнойИнформации *a, const char *type)
{
	size_t soap_flag_ns1__ВыгрузкаСправочнойИнформации = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ВыгрузкаСправочнойИнформации*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ВыгрузкаСправочнойИнформации, sizeof(struct __ns1__ВыгрузкаСправочнойИнформации), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ВыгрузкаСправочнойИнформации(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ВыгрузкаСправочнойИнформации && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ВыгрузкаСправочнойИнформации(soap, "ns1:ВыгрузкаСправочнойИнформации", &a->ns1__ВыгрузкаСправочнойИнформации, ""))
				{	soap_flag_ns1__ВыгрузкаСправочнойИнформации--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ВыгрузкаСправочнойИнформации * SOAP_FMAC2 soap_instantiate___ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ВыгрузкаСправочнойИнформации(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ВыгрузкаСправочнойИнформации *p;
	size_t k = sizeof(struct __ns1__ВыгрузкаСправочнойИнформации);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ВыгрузкаСправочнойИнформации, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ВыгрузкаСправочнойИнформации);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ВыгрузкаСправочнойИнформации, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ВыгрузкаСправочнойИнформации location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, const struct __ns1__ВыгрузкаСправочнойИнформации *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ВыгрузкаСправочнойИнформации(soap, tag ? tag : "-ns1:ВыгрузкаСправочнойИнформации", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ВыгрузкаСправочнойИнформации * SOAP_FMAC4 soap_get___ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, struct __ns1__ВыгрузкаСправочнойИнформации *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ВыгрузкаСправочнойИнформации(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ПринятьПакетОбмена(struct soap *soap, struct __ns1__ПринятьПакетОбмена *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ПринятьПакетОбмена = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ПринятьПакетОбмена(struct soap *soap, const struct __ns1__ПринятьПакетОбмена *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ПринятьПакетОбмена(soap, &a->ns1__ПринятьПакетОбмена);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ПринятьПакетОбмена(struct soap *soap, const char *tag, int id, const struct __ns1__ПринятьПакетОбмена *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ПринятьПакетОбмена(soap, "ns1:ПринятьПакетОбмена", -1, &a->ns1__ПринятьПакетОбмена, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ПринятьПакетОбмена * SOAP_FMAC4 soap_in___ns1__ПринятьПакетОбмена(struct soap *soap, const char *tag, struct __ns1__ПринятьПакетОбмена *a, const char *type)
{
	size_t soap_flag_ns1__ПринятьПакетОбмена = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ПринятьПакетОбмена*)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ПринятьПакетОбмена, sizeof(struct __ns1__ПринятьПакетОбмена), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ПринятьПакетОбмена(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ПринятьПакетОбмена && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ПринятьПакетОбмена(soap, "ns1:ПринятьПакетОбмена", &a->ns1__ПринятьПакетОбмена, ""))
				{	soap_flag_ns1__ПринятьПакетОбмена--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ПринятьПакетОбмена * SOAP_FMAC2 soap_instantiate___ns1__ПринятьПакетОбмена(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ПринятьПакетОбмена(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ПринятьПакетОбмена *p;
	size_t k = sizeof(struct __ns1__ПринятьПакетОбмена);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ПринятьПакетОбмена, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ПринятьПакетОбмена);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ПринятьПакетОбмена, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ПринятьПакетОбмена location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ПринятьПакетОбмена(struct soap *soap, const struct __ns1__ПринятьПакетОбмена *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ПринятьПакетОбмена(soap, tag ? tag : "-ns1:ПринятьПакетОбмена", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ПринятьПакетОбмена * SOAP_FMAC4 soap_get___ns1__ПринятьПакетОбмена(struct soap *soap, struct __ns1__ПринятьПакетОбмена *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ПринятьПакетОбмена(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_ValueListType(struct soap *soap, int choice, const union _ns1__union_ValueListType *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_ValueListType_valueType:
		soap_serialize_PointerTons1__TypeDescription(soap, &a->valueType);
		break;
	case SOAP_UNION__ns1__union_ValueListType_availableValues:
		soap_serialize_PointerTons1__ValueListType(soap, &a->availableValues);
		break;
	case SOAP_UNION__ns1__union_ValueListType_lastId:
		soap_embedded(soap, &a->lastId, SOAP_TYPE_LONG64);
		break;
	case SOAP_UNION__ns1__union_ValueListType_item:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__ValueListItemType(soap, &a->item);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_ValueListType(struct soap *soap, int choice, const union _ns1__union_ValueListType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_ValueListType_valueType:
		return soap_out_PointerTons1__TypeDescription(soap, "ns1:valueType", -1, &a->valueType, "");
	case SOAP_UNION__ns1__union_ValueListType_availableValues:
		return soap_out_PointerTons1__ValueListType(soap, "ns1:availableValues", -1, &a->availableValues, "");
	case SOAP_UNION__ns1__union_ValueListType_lastId:
		return soap_out_LONG64(soap, "ns1:lastId", -1, &a->lastId, "");
	case SOAP_UNION__ns1__union_ValueListType_item:
		return soap_out_PointerTostd__vectorTemplateOfPointerTons1__ValueListItemType(soap, "ns1:item", -1, &a->item, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_ValueListType * SOAP_FMAC4 soap_in__ns1__union_ValueListType(struct soap *soap, int *choice, union _ns1__union_ValueListType *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->valueType = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__TypeDescription(soap, "ns1:valueType", &a->valueType, "ns1:TypeDescription"))
	{	*choice = SOAP_UNION__ns1__union_ValueListType_valueType;
		return a;
	}
	a->availableValues = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ValueListType(soap, "ns1:availableValues", &a->availableValues, "ns1:ValueListType"))
	{	*choice = SOAP_UNION__ns1__union_ValueListType_availableValues;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_LONG64(soap, "ns1:lastId", &a->lastId, "xsd:long"))
	{	*choice = SOAP_UNION__ns1__union_ValueListType_lastId;
		return a;
	}
	a->item = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTons1__ValueListItemType(soap, "ns1:item", &a->item, "ns1:ValueListItemType"))
	{	*choice = SOAP_UNION__ns1__union_ValueListType_item;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__MozaicAuthorization(struct soap *soap, _ns1__MozaicAuthorization *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__MozaicAuthorization))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__MozaicAuthorization(struct soap *soap, const char *tag, int id, _ns1__MozaicAuthorization *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__MozaicAuthorization, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__MozaicAuthorization ? type : NULL);
}

SOAP_FMAC3 _ns1__MozaicAuthorization ** SOAP_FMAC4 soap_in_PointerTo_ns1__MozaicAuthorization(struct soap *soap, const char *tag, _ns1__MozaicAuthorization **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__MozaicAuthorization **)soap_malloc(soap, sizeof(_ns1__MozaicAuthorization *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__MozaicAuthorization *)soap_instantiate__ns1__MozaicAuthorization(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__MozaicAuthorization **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__MozaicAuthorization, sizeof(_ns1__MozaicAuthorization), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__MozaicAuthorization(struct soap *soap, _ns1__MozaicAuthorization *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__MozaicAuthorization(soap, tag ? tag : "ns1:MozaicAuthorization", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__MozaicAuthorization ** SOAP_FMAC4 soap_get_PointerTo_ns1__MozaicAuthorization(struct soap *soap, _ns1__MozaicAuthorization **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__MozaicAuthorization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__СинхронизацияСправочнойИнформации(struct soap *soap, _ns1__СинхронизацияСправочнойИнформации *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__СинхронизацияСправочнойИнформации(struct soap *soap, const char *tag, int id, _ns1__СинхронизацияСправочнойИнформации *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации ? type : NULL);
}

SOAP_FMAC3 _ns1__СинхронизацияСправочнойИнформации ** SOAP_FMAC4 soap_in_PointerTo_ns1__СинхронизацияСправочнойИнформации(struct soap *soap, const char *tag, _ns1__СинхронизацияСправочнойИнформации **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__СинхронизацияСправочнойИнформации **)soap_malloc(soap, sizeof(_ns1__СинхронизацияСправочнойИнформации *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__СинхронизацияСправочнойИнформации *)soap_instantiate__ns1__СинхронизацияСправочнойИнформации(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__СинхронизацияСправочнойИнформации **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__СинхронизацияСправочнойИнформации, sizeof(_ns1__СинхронизацияСправочнойИнформации), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__СинхронизацияСправочнойИнформации(struct soap *soap, _ns1__СинхронизацияСправочнойИнформации *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__СинхронизацияСправочнойИнформации(soap, tag ? tag : "ns1:СинхронизацияСправочнойИнформации", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__СинхронизацияСправочнойИнформации ** SOAP_FMAC4 soap_get_PointerTo_ns1__СинхронизацияСправочнойИнформации(struct soap *soap, _ns1__СинхронизацияСправочнойИнформации **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__СинхронизацияСправочнойИнформации(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, _ns1__ВыгрузкаСправочнойИнформации *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, const char *tag, int id, _ns1__ВыгрузкаСправочнойИнформации *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации ? type : NULL);
}

SOAP_FMAC3 _ns1__ВыгрузкаСправочнойИнформации ** SOAP_FMAC4 soap_in_PointerTo_ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, const char *tag, _ns1__ВыгрузкаСправочнойИнформации **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ВыгрузкаСправочнойИнформации **)soap_malloc(soap, sizeof(_ns1__ВыгрузкаСправочнойИнформации *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ВыгрузкаСправочнойИнформации *)soap_instantiate__ns1__ВыгрузкаСправочнойИнформации(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ВыгрузкаСправочнойИнформации **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ВыгрузкаСправочнойИнформации, sizeof(_ns1__ВыгрузкаСправочнойИнформации), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, _ns1__ВыгрузкаСправочнойИнформации *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ВыгрузкаСправочнойИнформации(soap, tag ? tag : "ns1:ВыгрузкаСправочнойИнформации", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ВыгрузкаСправочнойИнформации ** SOAP_FMAC4 soap_get_PointerTo_ns1__ВыгрузкаСправочнойИнформации(struct soap *soap, _ns1__ВыгрузкаСправочнойИнформации **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ВыгрузкаСправочнойИнформации(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ПринятьПакетОбмена(struct soap *soap, _ns1__ПринятьПакетОбмена *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ПринятьПакетОбмена))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ПринятьПакетОбмена(struct soap *soap, const char *tag, int id, _ns1__ПринятьПакетОбмена *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ПринятьПакетОбмена, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ПринятьПакетОбмена ? type : NULL);
}

SOAP_FMAC3 _ns1__ПринятьПакетОбмена ** SOAP_FMAC4 soap_in_PointerTo_ns1__ПринятьПакетОбмена(struct soap *soap, const char *tag, _ns1__ПринятьПакетОбмена **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ПринятьПакетОбмена **)soap_malloc(soap, sizeof(_ns1__ПринятьПакетОбмена *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ПринятьПакетОбмена *)soap_instantiate__ns1__ПринятьПакетОбмена(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ПринятьПакетОбмена **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ПринятьПакетОбмена, sizeof(_ns1__ПринятьПакетОбмена), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ПринятьПакетОбмена(struct soap *soap, _ns1__ПринятьПакетОбмена *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ПринятьПакетОбмена(soap, tag ? tag : "ns1:ПринятьПакетОбмена", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ПринятьПакетОбмена ** SOAP_FMAC4 soap_get_PointerTo_ns1__ПринятьПакетОбмена(struct soap *soap, _ns1__ПринятьПакетОбмена **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ПринятьПакетОбмена(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_xsd__base64Binary, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xsd__base64Binary ? type : NULL);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ValueStorage(struct soap *soap, xsd__base64Binary *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_ns1__ValueStorage(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ValueStorage(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_ns1__ValueStorage, NULL);
	if (!*a || id < 0)
		return soap->error;
	return soap_out_ns1__ValueStorage(soap, tag, id, *a, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerTons1__ValueStorage(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ValueStorage(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ValueStorage, sizeof(xsd__base64Binary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ValueStorage(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ValueStorage(soap, tag ? tag : "ns1:ValueStorage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerTons1__ValueStorage(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ValueStorage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ValueTreeRow(struct soap *soap, ns1__ValueTreeRow *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ValueTreeRow))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ValueTreeRow(struct soap *soap, const char *tag, int id, ns1__ValueTreeRow *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ValueTreeRow, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ValueTreeRow ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns1__ValueTreeRow ** SOAP_FMAC4 soap_in_PointerTons1__ValueTreeRow(struct soap *soap, const char *tag, ns1__ValueTreeRow **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ValueTreeRow **)soap_malloc(soap, sizeof(ns1__ValueTreeRow *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ValueTreeRow *)soap_instantiate_ns1__ValueTreeRow(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ValueTreeRow **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ValueTreeRow, sizeof(ns1__ValueTreeRow), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ValueTreeRow(struct soap *soap, ns1__ValueTreeRow *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ValueTreeRow(soap, tag ? tag : "ns1:ValueTreeRow", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ValueTreeRow ** SOAP_FMAC4 soap_get_PointerTons1__ValueTreeRow(struct soap *soap, ns1__ValueTreeRow **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ValueTreeRow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ValueTreeColumn(struct soap *soap, ns1__ValueTreeColumn *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ValueTreeColumn))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ValueTreeColumn(struct soap *soap, const char *tag, int id, ns1__ValueTreeColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ValueTreeColumn, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ValueTreeColumn ? type : NULL);
}

SOAP_FMAC3 ns1__ValueTreeColumn ** SOAP_FMAC4 soap_in_PointerTons1__ValueTreeColumn(struct soap *soap, const char *tag, ns1__ValueTreeColumn **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ValueTreeColumn **)soap_malloc(soap, sizeof(ns1__ValueTreeColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ValueTreeColumn *)soap_instantiate_ns1__ValueTreeColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ValueTreeColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ValueTreeColumn, sizeof(ns1__ValueTreeColumn), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ValueTreeColumn(struct soap *soap, ns1__ValueTreeColumn *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ValueTreeColumn(soap, tag ? tag : "ns1:ValueTreeColumn", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ValueTreeColumn ** SOAP_FMAC4 soap_get_PointerTons1__ValueTreeColumn(struct soap *soap, ns1__ValueTreeColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ValueTreeColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger))
		soap_serialize_xsd__nonNegativeInteger(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__nonNegativeInteger, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__nonNegativeInteger(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NMTOKEN(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__NMTOKEN))
		soap_serialize_xsd__NMTOKEN(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NMTOKEN(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__NMTOKEN, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__NMTOKEN(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__NMTOKEN(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__NMTOKEN(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NMTOKEN(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__NMTOKEN(soap, tag ? tag : "xsd:NMTOKEN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__NMTOKEN(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__NMTOKEN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ValueTableRow(struct soap *soap, ns1__ValueTableRow *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ValueTableRow))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ValueTableRow(struct soap *soap, const char *tag, int id, ns1__ValueTableRow *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ValueTableRow, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ValueTableRow ? type : NULL);
}

SOAP_FMAC3 ns1__ValueTableRow ** SOAP_FMAC4 soap_in_PointerTons1__ValueTableRow(struct soap *soap, const char *tag, ns1__ValueTableRow **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ValueTableRow **)soap_malloc(soap, sizeof(ns1__ValueTableRow *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ValueTableRow *)soap_instantiate_ns1__ValueTableRow(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ValueTableRow **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ValueTableRow, sizeof(ns1__ValueTableRow), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ValueTableRow(struct soap *soap, ns1__ValueTableRow *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ValueTableRow(soap, tag ? tag : "ns1:ValueTableRow", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ValueTableRow ** SOAP_FMAC4 soap_get_PointerTons1__ValueTableRow(struct soap *soap, ns1__ValueTableRow **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ValueTableRow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ValueTableIndex(struct soap *soap, ns1__ValueTableIndex *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ValueTableIndex))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ValueTableIndex(struct soap *soap, const char *tag, int id, ns1__ValueTableIndex *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ValueTableIndex, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ValueTableIndex ? type : NULL);
}

SOAP_FMAC3 ns1__ValueTableIndex ** SOAP_FMAC4 soap_in_PointerTons1__ValueTableIndex(struct soap *soap, const char *tag, ns1__ValueTableIndex **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ValueTableIndex **)soap_malloc(soap, sizeof(ns1__ValueTableIndex *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ValueTableIndex *)soap_instantiate_ns1__ValueTableIndex(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ValueTableIndex **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ValueTableIndex, sizeof(ns1__ValueTableIndex), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ValueTableIndex(struct soap *soap, ns1__ValueTableIndex *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ValueTableIndex(soap, tag ? tag : "ns1:ValueTableIndex", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ValueTableIndex ** SOAP_FMAC4 soap_get_PointerTons1__ValueTableIndex(struct soap *soap, ns1__ValueTableIndex **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ValueTableIndex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ValueTableColumn(struct soap *soap, ns1__ValueTableColumn *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ValueTableColumn))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ValueTableColumn(struct soap *soap, const char *tag, int id, ns1__ValueTableColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ValueTableColumn, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ValueTableColumn ? type : NULL);
}

SOAP_FMAC3 ns1__ValueTableColumn ** SOAP_FMAC4 soap_in_PointerTons1__ValueTableColumn(struct soap *soap, const char *tag, ns1__ValueTableColumn **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ValueTableColumn **)soap_malloc(soap, sizeof(ns1__ValueTableColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ValueTableColumn *)soap_instantiate_ns1__ValueTableColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ValueTableColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ValueTableColumn, sizeof(ns1__ValueTableColumn), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ValueTableColumn(struct soap *soap, ns1__ValueTableColumn *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ValueTableColumn(soap, tag ? tag : "ns1:ValueTableColumn", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ValueTableColumn ** SOAP_FMAC4 soap_get_PointerTons1__ValueTableColumn(struct soap *soap, ns1__ValueTableColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ValueTableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__ValueListItemType(struct soap *soap, std::vector<ns1__ValueListItemType *> *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueListItemType))
		soap_serialize_std__vectorTemplateOfPointerTons1__ValueListItemType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__ValueListItemType(struct soap *soap, const char *tag, int id, std::vector<ns1__ValueListItemType *> *const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTons1__ValueListItemType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<ns1__ValueListItemType *> ** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__ValueListItemType(struct soap *soap, const char *tag, std::vector<ns1__ValueListItemType *> **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<ns1__ValueListItemType *> **)soap_malloc(soap, sizeof(std::vector<ns1__ValueListItemType *> *))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__ValueListItemType(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__ValueListItemType(struct soap *soap, std::vector<ns1__ValueListItemType *> *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__vectorTemplateOfPointerTons1__ValueListItemType(soap, tag ? tag : "", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<ns1__ValueListItemType *> ** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__ValueListItemType(struct soap *soap, std::vector<ns1__ValueListItemType *> **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__ValueListItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ValueListItemType(struct soap *soap, ns1__ValueListItemType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ValueListItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ValueListItemType(struct soap *soap, const char *tag, int id, ns1__ValueListItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ValueListItemType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ValueListItemType ? type : NULL);
}

SOAP_FMAC3 ns1__ValueListItemType ** SOAP_FMAC4 soap_in_PointerTons1__ValueListItemType(struct soap *soap, const char *tag, ns1__ValueListItemType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ValueListItemType **)soap_malloc(soap, sizeof(ns1__ValueListItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ValueListItemType *)soap_instantiate_ns1__ValueListItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ValueListItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ValueListItemType, sizeof(ns1__ValueListItemType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ValueListItemType(struct soap *soap, ns1__ValueListItemType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ValueListItemType(soap, tag ? tag : "ns1:ValueListItemType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ValueListItemType ** SOAP_FMAC4 soap_get_PointerTons1__ValueListItemType(struct soap *soap, ns1__ValueListItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ValueListItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ValueListType(struct soap *soap, ns1__ValueListType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ValueListType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ValueListType(struct soap *soap, const char *tag, int id, ns1__ValueListType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ValueListType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ValueListType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns1__ValueListType ** SOAP_FMAC4 soap_in_PointerTons1__ValueListType(struct soap *soap, const char *tag, ns1__ValueListType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ValueListType **)soap_malloc(soap, sizeof(ns1__ValueListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ValueListType *)soap_instantiate_ns1__ValueListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ValueListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ValueListType, sizeof(ns1__ValueListType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ValueListType(struct soap *soap, ns1__ValueListType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ValueListType(soap, tag ? tag : "ns1:ValueListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ValueListType ** SOAP_FMAC4 soap_get_PointerTons1__ValueListType(struct soap *soap, ns1__ValueListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ValueListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TypeDescription(struct soap *soap, ns1__TypeDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TypeDescription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TypeDescription(struct soap *soap, const char *tag, int id, ns1__TypeDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TypeDescription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TypeDescription ? type : NULL);
}

SOAP_FMAC3 ns1__TypeDescription ** SOAP_FMAC4 soap_in_PointerTons1__TypeDescription(struct soap *soap, const char *tag, ns1__TypeDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TypeDescription **)soap_malloc(soap, sizeof(ns1__TypeDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TypeDescription *)soap_instantiate_ns1__TypeDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TypeDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TypeDescription, sizeof(ns1__TypeDescription), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TypeDescription(struct soap *soap, ns1__TypeDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TypeDescription(soap, tag ? tag : "ns1:TypeDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TypeDescription ** SOAP_FMAC4 soap_get_PointerTons1__TypeDescription(struct soap *soap, ns1__TypeDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TypeDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToLONG64(soap, tag ? tag : "long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__decimal(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__decimal))
		soap_serialize_xsd__decimal(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__decimal(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__decimal, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__decimal(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__decimal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__decimal(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__decimal(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BinaryDataQualifiers(struct soap *soap, ns1__BinaryDataQualifiers *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BinaryDataQualifiers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BinaryDataQualifiers(struct soap *soap, const char *tag, int id, ns1__BinaryDataQualifiers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BinaryDataQualifiers, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__BinaryDataQualifiers ? type : NULL);
}

SOAP_FMAC3 ns1__BinaryDataQualifiers ** SOAP_FMAC4 soap_in_PointerTons1__BinaryDataQualifiers(struct soap *soap, const char *tag, ns1__BinaryDataQualifiers **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BinaryDataQualifiers **)soap_malloc(soap, sizeof(ns1__BinaryDataQualifiers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BinaryDataQualifiers *)soap_instantiate_ns1__BinaryDataQualifiers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__BinaryDataQualifiers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BinaryDataQualifiers, sizeof(ns1__BinaryDataQualifiers), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BinaryDataQualifiers(struct soap *soap, ns1__BinaryDataQualifiers *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__BinaryDataQualifiers(soap, tag ? tag : "ns1:BinaryDataQualifiers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BinaryDataQualifiers ** SOAP_FMAC4 soap_get_PointerTons1__BinaryDataQualifiers(struct soap *soap, ns1__BinaryDataQualifiers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BinaryDataQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DateQualifiers(struct soap *soap, ns1__DateQualifiers *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DateQualifiers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DateQualifiers(struct soap *soap, const char *tag, int id, ns1__DateQualifiers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DateQualifiers, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DateQualifiers ? type : NULL);
}

SOAP_FMAC3 ns1__DateQualifiers ** SOAP_FMAC4 soap_in_PointerTons1__DateQualifiers(struct soap *soap, const char *tag, ns1__DateQualifiers **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DateQualifiers **)soap_malloc(soap, sizeof(ns1__DateQualifiers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DateQualifiers *)soap_instantiate_ns1__DateQualifiers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DateQualifiers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DateQualifiers, sizeof(ns1__DateQualifiers), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DateQualifiers(struct soap *soap, ns1__DateQualifiers *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DateQualifiers(soap, tag ? tag : "ns1:DateQualifiers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DateQualifiers ** SOAP_FMAC4 soap_get_PointerTons1__DateQualifiers(struct soap *soap, ns1__DateQualifiers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DateQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StringQualifiers(struct soap *soap, ns1__StringQualifiers *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StringQualifiers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StringQualifiers(struct soap *soap, const char *tag, int id, ns1__StringQualifiers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StringQualifiers, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__StringQualifiers ? type : NULL);
}

SOAP_FMAC3 ns1__StringQualifiers ** SOAP_FMAC4 soap_in_PointerTons1__StringQualifiers(struct soap *soap, const char *tag, ns1__StringQualifiers **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StringQualifiers **)soap_malloc(soap, sizeof(ns1__StringQualifiers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StringQualifiers *)soap_instantiate_ns1__StringQualifiers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__StringQualifiers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StringQualifiers, sizeof(ns1__StringQualifiers), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StringQualifiers(struct soap *soap, ns1__StringQualifiers *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__StringQualifiers(soap, tag ? tag : "ns1:StringQualifiers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StringQualifiers ** SOAP_FMAC4 soap_get_PointerTons1__StringQualifiers(struct soap *soap, ns1__StringQualifiers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StringQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NumberQualifiers(struct soap *soap, ns1__NumberQualifiers *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NumberQualifiers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NumberQualifiers(struct soap *soap, const char *tag, int id, ns1__NumberQualifiers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NumberQualifiers, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__NumberQualifiers ? type : NULL);
}

SOAP_FMAC3 ns1__NumberQualifiers ** SOAP_FMAC4 soap_in_PointerTons1__NumberQualifiers(struct soap *soap, const char *tag, ns1__NumberQualifiers **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NumberQualifiers **)soap_malloc(soap, sizeof(ns1__NumberQualifiers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NumberQualifiers *)soap_instantiate_ns1__NumberQualifiers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__NumberQualifiers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NumberQualifiers, sizeof(ns1__NumberQualifiers), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NumberQualifiers(struct soap *soap, ns1__NumberQualifiers *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__NumberQualifiers(soap, tag ? tag : "ns1:NumberQualifiers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NumberQualifiers ** SOAP_FMAC4 soap_get_PointerTons1__NumberQualifiers(struct soap *soap, ns1__NumberQualifiers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NumberQualifiers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LocalStringItemType(struct soap *soap, ns1__LocalStringItemType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LocalStringItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LocalStringItemType(struct soap *soap, const char *tag, int id, ns1__LocalStringItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LocalStringItemType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__LocalStringItemType ? type : NULL);
}

SOAP_FMAC3 ns1__LocalStringItemType ** SOAP_FMAC4 soap_in_PointerTons1__LocalStringItemType(struct soap *soap, const char *tag, ns1__LocalStringItemType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LocalStringItemType **)soap_malloc(soap, sizeof(ns1__LocalStringItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LocalStringItemType *)soap_instantiate_ns1__LocalStringItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__LocalStringItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LocalStringItemType, sizeof(ns1__LocalStringItemType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LocalStringItemType(struct soap *soap, ns1__LocalStringItemType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__LocalStringItemType(soap, tag ? tag : "ns1:LocalStringItemType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LocalStringItemType ** SOAP_FMAC4 soap_get_PointerTons1__LocalStringItemType(struct soap *soap, ns1__LocalStringItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LocalStringItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenericException(struct soap *soap, ns1__GenericException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenericException))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenericException(struct soap *soap, const char *tag, int id, ns1__GenericException *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenericException, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__GenericException ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns1__GenericException ** SOAP_FMAC4 soap_in_PointerTons1__GenericException(struct soap *soap, const char *tag, ns1__GenericException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenericException **)soap_malloc(soap, sizeof(ns1__GenericException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenericException *)soap_instantiate_ns1__GenericException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__GenericException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenericException, sizeof(ns1__GenericException), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenericException(struct soap *soap, ns1__GenericException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GenericException(soap, tag ? tag : "ns1:GenericException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GenericException ** SOAP_FMAC4 soap_get_PointerTons1__GenericException(struct soap *soap, ns1__GenericException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenericException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__KeyAndValue(struct soap *soap, ns1__KeyAndValue *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__KeyAndValue))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__KeyAndValue(struct soap *soap, const char *tag, int id, ns1__KeyAndValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__KeyAndValue, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__KeyAndValue ? type : NULL);
}

SOAP_FMAC3 ns1__KeyAndValue ** SOAP_FMAC4 soap_in_PointerTons1__KeyAndValue(struct soap *soap, const char *tag, ns1__KeyAndValue **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__KeyAndValue **)soap_malloc(soap, sizeof(ns1__KeyAndValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__KeyAndValue *)soap_instantiate_ns1__KeyAndValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__KeyAndValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__KeyAndValue, sizeof(ns1__KeyAndValue), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__KeyAndValue(struct soap *soap, ns1__KeyAndValue *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__KeyAndValue(soap, tag ? tag : "ns1:KeyAndValue", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__KeyAndValue ** SOAP_FMAC4 soap_get_PointerTons1__KeyAndValue(struct soap *soap, ns1__KeyAndValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__KeyAndValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DataFillError(struct soap *soap, ns1__DataFillError *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DataFillError))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DataFillError(struct soap *soap, const char *tag, int id, ns1__DataFillError *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DataFillError, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DataFillError ? type : NULL);
}

SOAP_FMAC3 ns1__DataFillError ** SOAP_FMAC4 soap_in_PointerTons1__DataFillError(struct soap *soap, const char *tag, ns1__DataFillError **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DataFillError **)soap_malloc(soap, sizeof(ns1__DataFillError *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DataFillError *)soap_instantiate_ns1__DataFillError(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DataFillError **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DataFillError, sizeof(ns1__DataFillError), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DataFillError(struct soap *soap, ns1__DataFillError *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DataFillError(soap, tag ? tag : "ns1:DataFillError", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DataFillError ** SOAP_FMAC4 soap_get_PointerTons1__DataFillError(struct soap *soap, ns1__DataFillError **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DataFillError(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ValueTreeRow(struct soap *soap, std::vector<ns1__ValueTreeRow *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ValueTreeRow(struct soap *soap, const std::vector<ns1__ValueTreeRow *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__ValueTreeRow *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ValueTreeRow(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ValueTreeRow(struct soap *soap, const char *tag, int id, const std::vector<ns1__ValueTreeRow *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__ValueTreeRow *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ValueTreeRow(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ValueTreeRow *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ValueTreeRow(struct soap *soap, const char *tag, std::vector<ns1__ValueTreeRow *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ValueTreeRow(soap)))
			return NULL;
		a->emplace_back();
		ns1__ValueTreeRow * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns1__ValueTreeRow, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTreeRow, sizeof(ns1__ValueTreeRow), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__ValueTreeRow(soap, tag, NULL, "ns1:ValueTreeRow"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__ValueTreeRow(soap, tag, n, "ns1:ValueTreeRow"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ValueTreeRow *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTreeRow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTreeRow(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__ValueTreeRow *> *p;
	size_t k = sizeof(std::vector<ns1__ValueTreeRow *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTreeRow, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__ValueTreeRow *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__ValueTreeRow *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__ValueTreeRow *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ValueTreeColumn(struct soap *soap, std::vector<ns1__ValueTreeColumn *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ValueTreeColumn(struct soap *soap, const std::vector<ns1__ValueTreeColumn *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__ValueTreeColumn *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ValueTreeColumn(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ValueTreeColumn(struct soap *soap, const char *tag, int id, const std::vector<ns1__ValueTreeColumn *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__ValueTreeColumn *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ValueTreeColumn(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ValueTreeColumn *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ValueTreeColumn(struct soap *soap, const char *tag, std::vector<ns1__ValueTreeColumn *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ValueTreeColumn(soap)))
			return NULL;
		a->emplace_back();
		ns1__ValueTreeColumn * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns1__ValueTreeColumn, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTreeColumn, sizeof(ns1__ValueTreeColumn), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__ValueTreeColumn(soap, tag, NULL, "ns1:ValueTreeColumn"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__ValueTreeColumn(soap, tag, n, "ns1:ValueTreeColumn"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ValueTreeColumn *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTreeColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTreeColumn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__ValueTreeColumn *> *p;
	size_t k = sizeof(std::vector<ns1__ValueTreeColumn *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTreeColumn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__ValueTreeColumn *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__ValueTreeColumn *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__ValueTreeColumn *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__NMTOKEN(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__NMTOKEN(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__NMTOKEN(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__NMTOKEN(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__NMTOKEN(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__NMTOKEN(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__NMTOKEN(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_xsd__NMTOKEN(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_xsd__NMTOKEN, SOAP_TYPE_std__vectorTemplateOfxsd__NMTOKEN, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__NMTOKEN(soap, tag, NULL, "xsd:NMTOKEN"))
				break;
		}
		else
		{	if (!soap_in_xsd__NMTOKEN(soap, tag, n, "xsd:NMTOKEN"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__NMTOKEN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__NMTOKEN(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__NMTOKEN, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ValueTableRow(struct soap *soap, std::vector<ns1__ValueTableRow *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ValueTableRow(struct soap *soap, const std::vector<ns1__ValueTableRow *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__ValueTableRow *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ValueTableRow(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ValueTableRow(struct soap *soap, const char *tag, int id, const std::vector<ns1__ValueTableRow *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__ValueTableRow *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ValueTableRow(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ValueTableRow *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ValueTableRow(struct soap *soap, const char *tag, std::vector<ns1__ValueTableRow *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ValueTableRow(soap)))
			return NULL;
		a->emplace_back();
		ns1__ValueTableRow * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns1__ValueTableRow, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableRow, sizeof(ns1__ValueTableRow), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__ValueTableRow(soap, tag, NULL, "ns1:ValueTableRow"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__ValueTableRow(soap, tag, n, "ns1:ValueTableRow"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ValueTableRow *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTableRow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTableRow(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__ValueTableRow *> *p;
	size_t k = sizeof(std::vector<ns1__ValueTableRow *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableRow, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__ValueTableRow *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__ValueTableRow *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__ValueTableRow *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ValueTableIndex(struct soap *soap, std::vector<ns1__ValueTableIndex *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ValueTableIndex(struct soap *soap, const std::vector<ns1__ValueTableIndex *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__ValueTableIndex *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ValueTableIndex(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ValueTableIndex(struct soap *soap, const char *tag, int id, const std::vector<ns1__ValueTableIndex *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__ValueTableIndex *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ValueTableIndex(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ValueTableIndex *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ValueTableIndex(struct soap *soap, const char *tag, std::vector<ns1__ValueTableIndex *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ValueTableIndex(soap)))
			return NULL;
		a->emplace_back();
		ns1__ValueTableIndex * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns1__ValueTableIndex, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableIndex, sizeof(ns1__ValueTableIndex), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__ValueTableIndex(soap, tag, NULL, "ns1:ValueTableIndex"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__ValueTableIndex(soap, tag, n, "ns1:ValueTableIndex"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ValueTableIndex *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTableIndex(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTableIndex(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__ValueTableIndex *> *p;
	size_t k = sizeof(std::vector<ns1__ValueTableIndex *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableIndex, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__ValueTableIndex *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__ValueTableIndex *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__ValueTableIndex *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ValueTableColumn(struct soap *soap, std::vector<ns1__ValueTableColumn *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ValueTableColumn(struct soap *soap, const std::vector<ns1__ValueTableColumn *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__ValueTableColumn *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ValueTableColumn(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ValueTableColumn(struct soap *soap, const char *tag, int id, const std::vector<ns1__ValueTableColumn *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__ValueTableColumn *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ValueTableColumn(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ValueTableColumn *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ValueTableColumn(struct soap *soap, const char *tag, std::vector<ns1__ValueTableColumn *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ValueTableColumn(soap)))
			return NULL;
		a->emplace_back();
		ns1__ValueTableColumn * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns1__ValueTableColumn, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableColumn, sizeof(ns1__ValueTableColumn), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__ValueTableColumn(soap, tag, NULL, "ns1:ValueTableColumn"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__ValueTableColumn(soap, tag, n, "ns1:ValueTableColumn"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ValueTableColumn *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTableColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ValueTableColumn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__ValueTableColumn *> *p;
	size_t k = sizeof(std::vector<ns1__ValueTableColumn *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueTableColumn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__ValueTableColumn *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__ValueTableColumn *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__ValueTableColumn *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ValueListItemType(struct soap *soap, std::vector<ns1__ValueListItemType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ValueListItemType(struct soap *soap, const std::vector<ns1__ValueListItemType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__ValueListItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ValueListItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ValueListItemType(struct soap *soap, const char *tag, int id, const std::vector<ns1__ValueListItemType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__ValueListItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ValueListItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ValueListItemType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ValueListItemType(struct soap *soap, const char *tag, std::vector<ns1__ValueListItemType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ValueListItemType(soap)))
			return NULL;
		a->emplace_back();
		ns1__ValueListItemType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns1__ValueListItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueListItemType, sizeof(ns1__ValueListItemType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__ValueListItemType(soap, tag, NULL, "ns1:ValueListItemType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__ValueListItemType(soap, tag, n, "ns1:ValueListItemType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ValueListItemType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ValueListItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ValueListItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__ValueListItemType *> *p;
	size_t k = sizeof(std::vector<ns1__ValueListItemType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ValueListItemType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__ValueListItemType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__ValueListItemType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__ValueListItemType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns1__UUID(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns1__UUID(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_ns1__UUID(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns1__UUID(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns1__UUID(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns1__UUID(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns1__UUID(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_ns1__UUID(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns1__UUID, SOAP_TYPE_std__vectorTemplateOfns1__UUID, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns1__UUID(soap, tag, NULL, "ns1:UUID"))
				break;
		}
		else
		{	if (!soap_in_ns1__UUID(soap, tag, n, "ns1:UUID"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns1__UUID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns1__UUID(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfns1__UUID, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__QName(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		std::string soap_tmp(soap_QName2s(soap, (*i).c_str()));
		if (soap_out_xsd__QName(soap, tag, id, &soap_tmp, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__QName(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_xsd__QName(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_xsd__QName, SOAP_TYPE_std__vectorTemplateOfxsd__QName, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__QName(soap, tag, NULL, "xsd:QName"))
				break;
		}
		else
		{	if (!soap_in_xsd__QName(soap, tag, n, "xsd:QName"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__QName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns1__Structure_Property(struct soap *soap, std::vector<_ns1__Structure_Property> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns1__Structure_Property(struct soap *soap, const std::vector<_ns1__Structure_Property> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_ns1__Structure_Property> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns1__Structure_Property(struct soap *soap, const char *tag, int id, const std::vector<_ns1__Structure_Property> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_ns1__Structure_Property> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns1__Structure_Property> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns1__Structure_Property(struct soap *soap, const char *tag, std::vector<_ns1__Structure_Property> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns1__Structure_Property(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_ns1__Structure_Property));
		}
		else
		{	a->emplace_back();
		}
		_ns1__Structure_Property *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__ns1__Structure_Property, SOAP_TYPE_std__vectorTemplateOf_ns1__Structure_Property, sizeof(_ns1__Structure_Property), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__ns1__Structure_Property(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__ns1__Structure_Property(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns1__Structure_Property>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns1__Structure_Property(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns1__Structure_Property(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_ns1__Structure_Property> *p;
	size_t k = sizeof(std::vector<_ns1__Structure_Property> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_ns1__Structure_Property, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_ns1__Structure_Property> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_ns1__Structure_Property> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_ns1__Structure_Property>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__LocalStringItemType(struct soap *soap, std::vector<ns1__LocalStringItemType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__LocalStringItemType(struct soap *soap, const std::vector<ns1__LocalStringItemType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__LocalStringItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__LocalStringItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__LocalStringItemType(struct soap *soap, const char *tag, int id, const std::vector<ns1__LocalStringItemType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__LocalStringItemType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__LocalStringItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__LocalStringItemType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__LocalStringItemType(struct soap *soap, const char *tag, std::vector<ns1__LocalStringItemType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__LocalStringItemType(soap)))
			return NULL;
		a->emplace_back();
		ns1__LocalStringItemType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns1__LocalStringItemType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__LocalStringItemType, sizeof(ns1__LocalStringItemType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__LocalStringItemType(soap, tag, NULL, "ns1:LocalStringItemType"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__LocalStringItemType(soap, tag, n, "ns1:LocalStringItemType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__LocalStringItemType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__LocalStringItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__LocalStringItemType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__LocalStringItemType *> *p;
	size_t k = sizeof(std::vector<ns1__LocalStringItemType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__LocalStringItemType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__LocalStringItemType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__LocalStringItemType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__LocalStringItemType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_ns1__FixedStructure_Property(struct soap *soap, std::vector<_ns1__FixedStructure_Property> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_ns1__FixedStructure_Property(struct soap *soap, const std::vector<_ns1__FixedStructure_Property> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_ns1__FixedStructure_Property> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_ns1__FixedStructure_Property(struct soap *soap, const char *tag, int id, const std::vector<_ns1__FixedStructure_Property> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_ns1__FixedStructure_Property> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_ns1__FixedStructure_Property> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_ns1__FixedStructure_Property(struct soap *soap, const char *tag, std::vector<_ns1__FixedStructure_Property> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_ns1__FixedStructure_Property(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_ns1__FixedStructure_Property));
		}
		else
		{	a->emplace_back();
		}
		_ns1__FixedStructure_Property *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__ns1__FixedStructure_Property, SOAP_TYPE_std__vectorTemplateOf_ns1__FixedStructure_Property, sizeof(_ns1__FixedStructure_Property), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__ns1__FixedStructure_Property(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__ns1__FixedStructure_Property(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_ns1__FixedStructure_Property>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_ns1__FixedStructure_Property(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_ns1__FixedStructure_Property(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_ns1__FixedStructure_Property> *p;
	size_t k = sizeof(std::vector<_ns1__FixedStructure_Property> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_ns1__FixedStructure_Property, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_ns1__FixedStructure_Property> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_ns1__FixedStructure_Property> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_ns1__FixedStructure_Property>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__KeyAndValue(struct soap *soap, std::vector<ns1__KeyAndValue *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__KeyAndValue(struct soap *soap, const std::vector<ns1__KeyAndValue *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__KeyAndValue *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__KeyAndValue(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__KeyAndValue(struct soap *soap, const char *tag, int id, const std::vector<ns1__KeyAndValue *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__KeyAndValue *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__KeyAndValue(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__KeyAndValue *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__KeyAndValue(struct soap *soap, const char *tag, std::vector<ns1__KeyAndValue *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__KeyAndValue(soap)))
			return NULL;
		a->emplace_back();
		ns1__KeyAndValue * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns1__KeyAndValue, SOAP_TYPE_std__vectorTemplateOfPointerTons1__KeyAndValue, sizeof(ns1__KeyAndValue), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__KeyAndValue(soap, tag, NULL, "ns1:KeyAndValue"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__KeyAndValue(soap, tag, n, "ns1:KeyAndValue"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__KeyAndValue *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__KeyAndValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__KeyAndValue(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__KeyAndValue *> *p;
	size_t k = sizeof(std::vector<ns1__KeyAndValue *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__KeyAndValue, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__KeyAndValue *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__KeyAndValue *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__KeyAndValue *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__DataFillError(struct soap *soap, std::vector<ns1__DataFillError *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__DataFillError(struct soap *soap, const std::vector<ns1__DataFillError *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__DataFillError *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__DataFillError(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__DataFillError(struct soap *soap, const char *tag, int id, const std::vector<ns1__DataFillError *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__DataFillError *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__DataFillError(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__DataFillError *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__DataFillError(struct soap *soap, const char *tag, std::vector<ns1__DataFillError *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__DataFillError(soap)))
			return NULL;
		a->emplace_back();
		ns1__DataFillError * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_ns1__DataFillError, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataFillError, sizeof(ns1__DataFillError), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__DataFillError(soap, tag, NULL, "ns1:DataFillError"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__DataFillError(soap, tag, n, "ns1:DataFillError"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__DataFillError *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__DataFillError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__DataFillError(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__DataFillError *> *p;
	size_t k = sizeof(std::vector<ns1__DataFillError *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DataFillError, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__DataFillError *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__DataFillError *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__DataFillError *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<char *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, (char*const*)&(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap)))
			return NULL;
		a->emplace_back();
		char * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{	if (!soap_inliteral(soap, tag, n))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<char *> *p;
	size_t k = sizeof(std::vector<char *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<char *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<char *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<char *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
//12345
